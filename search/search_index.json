{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RLLR - RoboLab Learning Resources Tieto dokumenty chc\u00fa pom\u00f4c\u0165 \u017eiakom nau\u010di\u0165 sa programova\u0165 Lego Mindstorms EV3 v programovacom jazyku Python .","title":"Home"},{"location":"#rllr-robolab-learning-resources","text":"Tieto dokumenty chc\u00fa pom\u00f4c\u0165 \u017eiakom nau\u010di\u0165 sa programova\u0165 Lego Mindstorms EV3 v programovacom jazyku Python .","title":"RLLR - RoboLab Learning Resources"},{"location":"01/","text":"\u00davod do Pythonu Python je jeden z mnoh\u00fdch programovac\u00edch jazykov . Tak ako \u013eudia medzi sebou sa rozpr\u00e1vame spolo\u010dn\u00fdm jazykom, potrebujeme sa nau\u010di\u0165 nov\u00fd jazyk, ktor\u00e9mu rozumie po\u010d\u00edta\u010d \u010di robot. Tak mu budeme vedie\u0165 poveda\u0165, kedy sa pohn\u00fa\u0165, ako r\u00fdchlo, \u010do zobrazi\u0165 na displeji, a podobne. Po\u010fme na to! Python ako kalkula\u010dka Spust\u00edme program IDLE . Otvor\u00ed sa okno podobn\u00e9 tomu na obr\u00e1zku ni\u017e\u0161ie. Tento program n\u00e1m bude sl\u00fa\u017ei\u0165 na p\u00edsanie zdrojov\u00e9ho k\u00f3du a jeho spustenie. Zdrojov\u00fd k\u00f3d -- to s\u00fa pr\u00edkazy, ktor\u00e9 nap\u00ed\u0161eme po\u010d\u00edta\u010du. On si potom tento k\u00f3d pre\u010d\u00edta riadok za riadkom a vykon\u00e1 ich. Hovor\u00edme tie\u017e, \u017ee ich interpretuje . V okne, ktor\u00e9 sa n\u00e1m otvorilo, m\u00f4\u017eeme zad\u00e1va\u0165 jednotliv\u00e9 pr\u00edkazy. Na poslednom riadku vid\u00edme tzv. prompt : >>> . Ozna\u010duje, \u017ee program je pripraven\u00fd po\u010d\u00fava\u0165 na na\u0161e pr\u00edkazy. Dok\u00e1\u017ee napr. fungova\u0165 ako kalkula\u010dka, sta\u010d\u00ed hne\u010f za prompt nap\u00edsa\u0165 jednoduch\u00fd pr\u00edklad a stla\u010di\u0165 Enter . >>> 40 + 2 42 >>> 30 - 5 * 8 - 10 Znak * znamen\u00e1 n\u00e1sobenie. Vid\u00edme, \u017ee Python pozn\u00e1 z\u00e1kladn\u00e9 matematick\u00e9 pravidl\u00e1, najprv vypo\u010d\u00edtal n\u00e1sobenie, a\u017e potom od\u010d\u00edtanie. Ak by sme ho predsa len chceli presved\u010di\u0165, aby najprv od\u010d\u00edtal, pou\u017eijeme z\u00e1tvorky. Rovnako ako v matematike. S t\u00fdm rozdielom, \u017ee mus\u00edme pou\u017ei\u0165 okr\u00fahle z\u00e1tvorky () , tie ostatn\u00e9 ( []{} ) maj\u00fa pre Python in\u00fd v\u00fdznam a len by sme ho poplietli. >>> ( 30 - 5 ) * 8 200 Pozrime sa na delenie: >>> 40 / 5 8.0 >>> 40 // 5 8 >>> 40 / 7 5.714285714285714 >>> 40 // 7 5 V Pythone sa rozli\u0161uj\u00fa dva typy delenia: / je klasick\u00e9 delenie ako ho pozn\u00e1me, // je celo\u010d\u00edseln\u00e9 delenie . To znamen\u00e1, \u017ee v\u00fdsledkom je \u010d\u00edslo, ko\u013ekokr\u00e1t najviac sa zmest\u00ed delite\u013e do delenca cel\u00fd. 7 * 5 = 35 , v\u0161etko je e\u0161te v poriadku, ale 7 * 6 = 42 , a to je u\u017e viac ne\u017e 40, preto 40 // 7 = 5 . Pozn\u00e1mka Presnej\u0161ie, // je delenie / nasledovan\u00e9 zaokr\u00fahlen\u00edm nadol. Uk\u00e1\u017eeme si e\u0161te dve matematick\u00e9 \u0161peciality. Modulo Alebo inak: zvy\u0161ok po celo\u010d\u00edselnom delen\u00ed. Je to t\u00e1 \u010das\u0165, ktor\u00e1 n\u00e1m e\u0161te ch\u00fdba, ke\u010f pou\u017eijeme celo\u010d\u00edseln\u00e9 delenie // namiesto / . Pre t\u00fato oper\u00e1ciu sa pou\u017e\u00edva znak % . >>> 40 % 7 5 >>> 40 % 5 0 >>> 40 // 7 * 7 + 40 % 7 40 \u00daloha Pre\u010do posledn\u00fd pr\u00edklad vy\u0161iel pr\u00e1ve 40? Fungovalo by to aj s in\u00fdmi \u010d\u00edslami? Napr. s trojkou: >>> 3 // 7 * 7 + 3 % 7 Bude v\u00fdsledok 3? Plat\u00ed to pre v\u0161etky \u010d\u00edsla? Na poslednom pr\u00edklade sa v\u00e1m mo\u017eno nepozd\u00e1va, \u017ee sme nepou\u017eli \u017eiadne z\u00e1tvorky. Nemuseli sme, lebo n\u00e1sobenie, delenie aj modulo maj\u00fa rovnak\u00fa prioritu . S\u010d\u00edtanie a od\u010d\u00edtanie maj\u00fa od nich men\u0161iu prioritu, tak\u017ee sa vyhodnotia nesk\u00f4r. To u\u017e vieme, ke\u010f sme toto spr\u00e1vanie zmenili pou\u017eit\u00edm z\u00e1tvoriek. No a pri viacer\u00fdch oper\u00e1ciach rovnakej priority za sebou, Python ich vyhodnocuje z\u013eava doprava. Znovu ako v matematike. Tak\u017ee tento pr\u00edklad sa interpretuje akoby bol uz\u00e1tvorkovan\u00fd takto: >>> (( 40 // 7 ) * 7 ) + ( 40 % 7 ) 40 Mocnina Pripome\u0148me si, \u017ee mocnina je opakovan\u00e9 n\u00e1sobenie. 2 3 = 2 * 2 * 2 = 8 V Pythone pou\u017e\u00edvame na umoc\u0148ovanie oper\u00e1tor ** : >>> 2 ** 3 8 >>> 4 ** 1 4 >>> 1 ** 1000000000 1 >>> 5 ** 0 1 Umoc\u0148ovanie m\u00e1 e\u0161te v\u00e4\u010d\u0161iu prioritu ne\u017e n\u00e1sobenie. >>> 4 * 2 ** 3 32 >>> ( 4 * 2 ) ** 3 512 \u00daloha Ak\u00fd je v\u00fdsledok nasleduj\u00facich matematick\u00fdch v\u00fdrazov? Overte si spr\u00e1vnu odpove\u010f vyu\u017eit\u00edm Python IDLE. - 5 + 8 - (5 + 8) 2 % 4 - 1 10 // 3 ** 2 5 / -3 5 // -3 * 3 + 5 % -3 Premenn\u00e9 Pri zlo\u017eitej\u0161\u00edch v\u00fdpo\u010dtoch si \u010dasto chceme ulo\u017ei\u0165 medziv\u00fdsledok. Modern\u00e9 kalkula\u010dky to zvl\u00e1dnu a Python IDLE tie\u017e! >>> x = 4 + 8 >>> x 12 >>> 2 * x 24 Pr\u00edkaz x = 4 + 8 znamen\u00e1 priradenie hodnoty na pravej strane ( 4 + 8 ) do premennej na \u013eavej strane ( x ). Najprv Python vypo\u010d\u00edta 4 + 8 . Potom si na miesto v pam\u00e4ti, kde m\u00e1 ulo\u017een\u00fd v\u00fdsledok, nalep\u00ed pozn\u00e1mku \"x\". Je to n\u00e1zov novej premennej, aby si pam\u00e4tal kam sa m\u00e1 pozrie\u0165, ke\u010f ju uvid\u00ed v na\u0161ich pr\u00edkazoch nabud\u00face. Napr. 2 * x -> 2 * 12 -> 24 . N\u00e1zvy m\u00f4\u017eu by\u0165 aj viacp\u00edsmenkov\u00e9, m\u00f4\u017eu obsahova\u0165 ve\u013ek\u00e9 aj mal\u00e9 znaky, tie\u017e cifry (ale cifra nem\u00f4\u017ee st\u00e1\u0165 na za\u010diatku mena) a podtr\u017e\u00edtko (\"_\"). \u010co sa stane ak budeme chcie\u0165 uk\u00e1za\u0165 hodnotu premennej, ktor\u00fa Python e\u0161te nepozn\u00e1? >>> y Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'y' is not defined V\u0161imnime si posledn\u00fd riadok. Hovor\u00ed n\u00e1m, \u017ee n\u00e1zov \"y\" nie je definovan\u00fd, in\u00fdmi slovami, nepozn\u00e1 ho, nevie kam sa pozrie\u0165. \u00daloha \u010co je v\u00fdsledkom nasleduj\u00facej postupnosti pr\u00edkazov? >>> a = 3 >>> b = 2 >>> a = a + b >>> b = a - b >>> a = a - b >>> a ? >>> b ? Aby sme si skratili z\u00e1pis, namiesto >>> a = a + b m\u00f4\u017eme pou\u017e\u00edva\u0165 >>> a += b V\u00fdznam je ten ist\u00fd. Rovnako existuje -= , *= , /= , //= , %= , **= . Vysk\u00fa\u0161ajte si pou\u017ei\u0165 niektor\u00e9 z nich. Tla\u010di\u0165! V tejto \u010dasti si uk\u00e1\u017eeme nov\u00fd pr\u00edkaz. Vol\u00e1 sa \"print\". Z angli\u010dtiny vieme odhadn\u00fa\u0165, na \u010do bude sl\u00fa\u017ei\u0165. Vyp\u00ed\u0161e text na obrazovku. Zatia\u013e sme pracovali len s \u010d\u00edslami, e\u0161te nie z textom. V Pythone sa text p\u00ed\u0161e medzi \u00favodzovky (\"). Pozor! Ak nap\u00ed\u0161eme text bez \u00favodzoviek, interpretuje sa to ako n\u00e1zov, ktor\u00fd bude Python h\u013eada\u0165 a pravdepodobne dostaneme podobn\u00fa s\u0165a\u017enos\u0165 ako naposledy (hovor\u00ed sa im chybov\u00e9 hl\u00e1\u0161ky ). >>> print ( \"Ahoj\" ) Ahoj >>> print ( Ahoj ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'Ahoj' is not defined Namiesto dvojit\u00fdch \u00favodzoviek sa daj\u00fa pou\u017ei\u0165 aj jednoduch\u00e9 ('). >>> print ( 'Cau' ) Cau Text s\u00edce nie je \u010d\u00edslo, ale v Pythone dok\u00e1\u017eeme text s\u010d\u00edtava\u0165 a dokonca aj n\u00e1sobi\u0165! >>> print ( 'Ahoj ' + 'Robo' + 'Lab' ) Ahoj RoboLab >>> print ( 'tra' + 'la' * 3 ) tralalala >>> print ( 3 + ' jablka' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unsupported operand type ( s ) for + : 'int' and 'str' S\u010d\u00edta\u0165 text a \u010d\u00edslo sa u\u017e ned\u00e1. To presne n\u00e1m povie chybov\u00e1 hl\u00e1\u0161ka na poslednom riadku: oper\u00e1tor + nefunguje s \u010d\u00edslom (ang. int eger) a textom (ang. character str ing). Ak potrebujeme vyp\u00edsa\u0165 v jednom pr\u00edkaze text a z\u00e1rove\u0148 aj \u010d\u00edslo, m\u00f4\u017eme ich oddeli\u0165 \u010diarkou. Python medzi ne automaticky vlo\u017e\u00ed medzeru. >>> pocet = 3 >>> print ( pocet ) 3 >>> print ( 'Mam' , pocet , 'jablka' ) Mam 3 jablka Tak\u017ee print funguje aj s \u010d\u00edslami, nielen textom! Pozor, m\u00f4\u017ee sa zda\u0165, \u017ee nasleduj\u00face riadky spravia to ist\u00e9, ale nie je to celkom tak. Za chv\u00ed\u013eu si o tom povieme viac. >>> 3 3 >>> print ( 3 ) 3 N\u00e1\u0161 prv\u00fd program Python IDLE obsahuje dve \u010dasti. Jednu z nich, pr\u00edkazov\u00fd riadok (tie\u017e shell ), sme pou\u017e\u00edvali doteraz. Sl\u00fa\u017ei na vykon\u00e1vanie jednotliv\u00fdch pr\u00edkazov, ale na\u0161e programy v bud\u00facnosti bud\u00fa omnoho dlh\u0161ie, pozost\u00e1vaj\u00fac z nieko\u013eko desiatok, aj stoviek riadkov. Tu n\u00e1m pom\u00f4\u017ee druh\u00e1 \u010das\u0165: editor . Otvor\u00edme ho cez \"File\" -> \"New\". Nap\u00ed\u0161me do\u0148 n\u00e1\u0161 prv\u00fd program: print ( 'Ahoj' , 'RoboLab' ) print ( 'RoboLab zdravi' ) Pou\u017e\u00edvame to, \u010do sme sa u\u017e nau\u010dili, ale tentokr\u00e1t nep\u00ed\u0161eme na\u0161e pr\u00edkazy do pr\u00edkazov\u00e9ho riadku a nevykonaj\u00fa sa hne\u010f. Ke\u010f chceme spusti\u0165 program, stla\u010d\u00edme kl\u00e1ves F5 . IDLE n\u00e1s vyzve aby sme si program ulo\u017eili a potom ho spust\u00ed v okne pr\u00edkazov\u00e9ho riadku. Mali by sme zbada\u0165 vyp\u00edsan\u00e9: Ahoj RoboLab RoboLab zdravi Vr\u00e1\u0165me sa teraz k probl\u00e9mu vypisovania \u010d\u00edsel. Ke\u010f spust\u00edme jednoduch\u00fd program, print ( 3 * 5 ) na v\u00fdstupe sa n\u00e1m zobraz\u00ed 15 . Sk\u00faste si to! Spr\u00e1vne, Python najprv vypo\u010d\u00edta \"3 * 5 = 15\" a n\u00e1sledne v\u00fdsledok pr\u00edkazom print vyp\u00ed\u0161e na obrazovku. Sk\u00fasme teraz spusti\u0165 program bez pr\u00edkazu print . 3 * 5 Na v\u00fdstupe sa n\u00e1m ni\u010d nezobraz\u00ed! Pre\u010do? Python znovu vyhodnot\u00ed \"3 * 5 = 15\", ale tento v\u00fdsledok sa strat\u00ed, nem\u00e1 \u017eiadny pr\u00edkaz, aby ho vyp\u00edsal. Pr\u00edkazov\u00fd riadok n\u00e1m v\u017edy aj uk\u00e1\u017ee v\u00fdsledok toho, \u010do mu zad\u00e1me. >>> 3 * 5 15 Ale ak chceme nie\u010do vyp\u00edsa\u0165 z programu , v\u017edy mus\u00edme pou\u017ei\u0165 pr\u00edkaz print ! Tip V uk\u00e1\u017ekach na t\u00fdchto str\u00e1nkach odl\u00ed\u0161ime pr\u00edkazov\u00fd riadok jednoducho: za\u010d\u00edna tromi v\u00e4\u010d\u0161\u00edtkami >>> . Ak tam nie s\u00fa, znamen\u00e1 to, \u017ee dan\u00e1 uk\u00e1\u017eka je program , a teda ho treba nap\u00edsa\u0165 do editoru. Pre\u010do si to nezopakova\u0165? Doteraz bol Python celkom nudn\u00fd. Ke\u010f sme chceli, aby n\u00e1m nie\u010do nap\u00edsal, museli sme mu to sami nap\u00edsa\u0165 a e\u0161te k tomu naviac dop\u00edsa\u0165 \"print\". Na \u010do n\u00e1m je tak\u00fd Python? Uk\u00e1\u017eme si teda, \u017ee je silnej\u0161\u00ed, ne\u017e sa zd\u00e1. Spustite si tento program. Predposledn\u00e9 dva riadky za\u010d\u00ednaj\u00fa \u0161tyrmi medzerami a namiesto \u0161tyroch stla\u010den\u00ed medzern\u00edka m\u00f4\u017eeme pou\u017ei\u0165 kl\u00e1ves Tab . i = 0 while i < 3 : print ( 'tra' + 'la' * i ) i += 1 print ( 'koniec' ) Zd\u00e1 sa, \u017ee sme pou\u017eili nov\u00fd pr\u00edkaz: while . Aby sme mu porozumeli, mus\u00edme si najprv poveda\u0165 nie\u010do o ne/pravd\u00e1ch v Pythone. Logick\u00e9 \u00e1no a nie Presu\u0148me sa nachv\u00ed\u013eu znovu do pr\u00edkazov\u00e9ho riadku. Pracovali sme u\u017e s textov\u00fdmi a \u010d\u00edseln\u00fdmi hodnotami, teraz si uk\u00e1\u017eeme logick\u00e9 hodnoty (ang. boolean pod\u013ea matematika Georgea Boolea ). Existuj\u00fa len dve: True (pravda) a False (nepravda). V po\u010d\u00edta\u010doch je v\u0161etko jasn\u00e9, bu\u010f to je jednoducho pravdiv\u00e9 alebo nie je. >>> 1 < 2 True >>> 3 < - 5 False >>> 2 == 2 True >>> 2 >= 1 True >>> 2 >= 2 True M\u00e1me celkovo 6 porovn\u00e1vac\u00edch oper\u00e1torov : Oper\u00e1tor V\u00fdznam == rovn\u00e1 sa != nerovn\u00e1 sa < men\u0161ie ne\u017e <= men\u0161ie, nanajv\u00fd\u0161 rovn\u00e9 > v\u00e4\u010d\u0161ie ne\u017e >= v\u00e4\u010d\u0161ie, nanajv\u00fd\u0161 rovn\u00e9 Pozor! Ak chceme porovn\u00e1va\u0165, pou\u017e\u00edvame == (dva znaky \"=\"), ale ak prira\u010fujeme hodnotu do premennej, pou\u017e\u00edvame len = (jeden znak \"=\"). >>> a = 1 >>> a == 1 True Porovn\u00e1va\u0165 nemus\u00edme len \u010d\u00edsla: >>> 'text' != 'text' False >>> 2 == 'text' False >>> 2 == '2' False >>> 2 < 'text' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'str' >>> 'text' < 'text' False >>> 'a' < 'b' True >>> 'a' < 'aa' True >>> 'ab' <= 'aa' False Textov\u00e9 re\u0165azce sa porovn\u00e1vaj\u00fa lexikograficky . To znamen\u00e1, ak nejak\u00e9 slovo n\u00e1jdeme v abecednom zozname sk\u00f4r ne\u017e nejak\u00e9 druh\u00e9 slovo, tak to prv\u00e9 bude men\u0161ie. \u010c\u00edslo sa nikdy nebude rovna\u0165 \u017eiadnemu textu a dokonca na men\u0161ie/va\u010d\u0161ie sa ani nem\u00f4\u017eeme sp\u00fdta\u0165. >>> False == False True >>> False == 0 True >>> True == 1 True >>> False < True True Logick\u00e9 hodnoty sa spr\u00e1vaj\u00fa ako \u010d\u00edsla, pri\u010dom False je nula a True jednotka. >>> True + True 2 >>> True * False 0 V Pythone m\u00e1 ka\u017ed\u00e1 premenn\u00e1 (a ka\u017ed\u00e1 hodnota) nejak\u00fd typ ( d\u00e1tov\u00fd typ ). Dok\u00e1\u017eeme ho zisti\u0165 pomocou pr\u00edkazu type : >>> type ( 3 ) < class ' int '> >>> type ( 'text' ) < class ' str '> >>> type ( True ) < class ' bool '> >>> a = False >>> type ( a ) < class ' bool '> S presn\u00fdm v\u00fdznamom slov\u00ed\u010dka class si zatia\u013e nebudeme l\u00e1ma\u0165 hlavu, sta\u010d\u00ed si zapam\u00e4ta\u0165, \u017ee ka\u017ed\u00e1 hodnota m\u00e1 nejak\u00fd jednozna\u010dn\u00fd typ. Pr\u00edkaz while Teraz u\u017e budeme vedie\u0165 pou\u017ei\u0165 pr\u00edkaz while (naz\u00fdva sa tie\u017e cyklus ): while \"podmienka\" : \"pr\u00edkaz 1\" \"pr\u00edkaz 2\" ... \"pr\u00edkaz 3\" ... \"while\" znamen\u00e1 po anglicky \"pok\u00fdm\". A tak mu Python aj rozumie. Pok\u00fdm je \"podmienka\" pravdiv\u00e1, teda True , tak bude postupne vykon\u00e1va\u0165 \"pr\u00edkaz 1\", \"pr\u00edkaz 2\", ..., v\u0161etko, \u010do je odsaden\u00e9 o \u0161tyri medzery vpravo (t\u00fdmto pr\u00edkazom hovor\u00edme telo cyklu ). Ke\u010f pr\u00edde na koniec, znovu sa sp\u00fdta, \u010di je \"podmienka\" pravdiv\u00e1, ak \u00e1no, vykon\u00e1 znovu telo cyklu. A tak st\u00e1le dokola. Ke\u010f u\u017e \"podmienka\" pravdiv\u00e1 nebude, Python sko\u010d\u00ed na \"pr\u00edkaz 3\" a pokra\u010duje \u010falej. Vysk\u00fa\u0161ajme si spravi\u0165 nekone\u010dn\u00fd cyklus. Nap\u00ed\u0161eme tak\u00fdto jednoduch\u00fd program: while 1 == 1 : print ( 'ahoj' ) Spust\u00edme, a ke\u010f\u017ee 1 == 1 sa v\u017edy vyhodnot\u00ed na True , tak m\u00e1me cel\u00fa obrazovku \"ahoj\"ov. Program m\u00f4\u017eme zastavi\u0165 kl\u00e1vesovou kombin\u00e1ciou Ctrl+C. Rovnako by sme mohli nap\u00edsa\u0165: while True : print ( 'ahoj' ) \u00daloha \u010co vyp\u00ed\u0161e nasleduj\u00faci program? while False : print ( 'ahoj' ) print ( 'koniec' ) Najprv sk\u00faste na to pr\u00eds\u0165 sami, odpove\u010f si potom overte spusten\u00edm. Vieme u\u017e dos\u0165 na to, aby sme si nap\u00edsali trochu zauj\u00edmavej\u0161\u00ed program. Budeme \"kresli\u0165\" trojuholn\u00edky z hviezdi\u010diek (*). Od teraz budeme p\u00edsa\u0165 zdrojov\u00fd k\u00f3d po anglicky. Nebud\u00fa sa n\u00e1m mie\u0161a\u0165 slovensk\u00e9 a anglick\u00e9 slov\u00e1 (napr. print ( 'jablko' ) ), a ke\u010f vytvor\u00edme nejak\u00fd \u00fa\u017easn\u00fd program, budeme sa m\u00f4c\u0165 o\u0148 podeli\u0165 s cel\u00fdm svetom! Ako chceme aby vyzerali trojuholn\u00edky z hviezdi\u010diek? Najmen\u0161\u00ed trojuholn\u00edk ve\u013ekosti 1 je jednoduch\u00fd: * Ve\u013ekos\u0165 dva: ** * Ve\u013ekos\u0165 4: **** *** ** * U\u017e m\u00e1me predstavu, \u010do chceme naprogramova\u0165, tak\u017ee pustime sa do toho. Potrebujeme vedie\u0165, ak\u00fd ve\u013ek\u00fd trojuholn\u00edk chceme. size = 3 Vid\u00edme, \u017ee trojuholn\u00edk je nakreslen\u00fd na to\u013eko isto riadkov ak\u00e1 je jeho ve\u013ekos\u0165. size = 3 while size > 0 : # print one row size -= 1 Na miesto # print one row nap\u00ed\u0161eme k\u00f3d, ktor\u00fd to vykon\u00e1, zatia\u013e sme si to len pozna\u010dili. Tak\u00e1to \u010das\u0165 v zdrojovom k\u00f3de sa naz\u00fdva koment\u00e1r . Za\u010d\u00edna sa znakom \"#\" a pokra\u010duje a\u017e do konca riadku. Koment\u00e1re Python ignoruje, s\u00fa to pozn\u00e1mky n\u00e1s, program\u00e1torov. Ak by sme \u00favodn\u00fd \"#\" nepou\u017eili, Python by sa sna\u017eil interpretova\u0165 dan\u00fd riadok ako pr\u00edkaz a skon\u010dil by s chybovou hl\u00e1\u0161kou. Pozrime sa na to, ako sme pou\u017eili premenn\u00fa \"size\" v podmienke cyklu. Na za\u010diatku programu sa nastav\u00ed na hodnotu 3. Podmienka size > 0 sa vyhodnot\u00ed na True a telo cyklu sa vykon\u00e1. V \u0148om m\u00e1me pr\u00edkaz size -= 1 . Tak\u017ee teraz u\u017e plat\u00ed \"size = 2\". Znovu pr\u00edde na podmienku cyklu, \"2 > 0\", a teda telo cyklu sa vykon\u00e1, \"size\" sa zn\u00ed\u017ei o jedna, na hodnotu 1. Podmienka je znovu vyhodnoten\u00e1 ako True , \"size\" sa zn\u00ed\u017ei na hodnotu 0. Teraz u\u017e podmienka splnen\u00e1 nie je a telo cyklu sa nezopakuje. Celkovo sa teda cyklus zopakoval 3 kr\u00e1t. Presne to sme chceli! Zost\u00e1va n\u00e1m v ka\u017edom opakovan\u00ed vykresli\u0165 jeden riadok. Na prvom riadku chceme ma\u0165 3 hviezdi\u010dky. Na druhom 2 a na poslednom jednu. size = 3 while size > 0 : print ( '*' * size ) size -= 1 Hur\u00e1 a je to! Teraz sta\u010d\u00ed zmeni\u0165 v prvom riadku \"size\" na ve\u013ekos\u0165 ak\u00fa chceme a Python n\u00e1m vykresl\u00ed \u017eiadan\u00fd trojuholn\u00edk. Vysk\u00fa\u0161ajte si r\u00f4zne ve\u013ekosti. \u00daloha 1 Nap\u00ed\u0161te program podobn\u00fd tomu posledn\u00e9mu, ktor\u00fd bude kresli\u0165 \u0161tvorce. \u00daloha 2 Nap\u00ed\u0161te program kresliaci trojuholn\u00edky, ale naopak ako doteraz. Teda, pre ve\u013ekos\u0165 4 bude vyzera\u0165: * ** *** **** Toto je u\u017e trochu \u0165a\u017e\u0161ia \u00faloha, vy\u017eaduje pou\u017ei\u0165 a\u017e dve premenn\u00e9. \"size\" sa tentokr\u00e1t meni\u0165 nebude, ale druh\u00e1 premenn\u00e1 bude ma\u0165 postupne hodnoty od 1 a\u017e po \"size\", tak\u017ee budete vedie\u0165 jednoducho vykresli\u0165 hviezdi\u010dky na ka\u017edom riadku pod\u013ea nej. Premyslite si to dobre. \u00daloha 3 Nap\u00ed\u0161te program, ktor\u00fd vykresl\u00ed obd\u013a\u017enik. Na za\u010diatku bud\u00fa teda dve premenn\u00e9: jedna pre ve\u013ekos\u0165 ka\u017edej strany. \u00daloha 4 Pozor, toto je ve\u013emi tvrd\u00fd orie\u0161ok! Nap\u00ed\u0161te program, tentokr\u00e1t kresliaci pyram\u00eddu. Tu s\u00fa vzory pre ve\u013ekosti 1, 2 a 4: * * *** * *** ***** *******","title":"\u00davod do Pythonu"},{"location":"01/#uvod-do-pythonu","text":"Python je jeden z mnoh\u00fdch programovac\u00edch jazykov . Tak ako \u013eudia medzi sebou sa rozpr\u00e1vame spolo\u010dn\u00fdm jazykom, potrebujeme sa nau\u010di\u0165 nov\u00fd jazyk, ktor\u00e9mu rozumie po\u010d\u00edta\u010d \u010di robot. Tak mu budeme vedie\u0165 poveda\u0165, kedy sa pohn\u00fa\u0165, ako r\u00fdchlo, \u010do zobrazi\u0165 na displeji, a podobne. Po\u010fme na to!","title":"\u00davod do Pythonu"},{"location":"01/#python-ako-kalkulacka","text":"Spust\u00edme program IDLE . Otvor\u00ed sa okno podobn\u00e9 tomu na obr\u00e1zku ni\u017e\u0161ie. Tento program n\u00e1m bude sl\u00fa\u017ei\u0165 na p\u00edsanie zdrojov\u00e9ho k\u00f3du a jeho spustenie. Zdrojov\u00fd k\u00f3d -- to s\u00fa pr\u00edkazy, ktor\u00e9 nap\u00ed\u0161eme po\u010d\u00edta\u010du. On si potom tento k\u00f3d pre\u010d\u00edta riadok za riadkom a vykon\u00e1 ich. Hovor\u00edme tie\u017e, \u017ee ich interpretuje . V okne, ktor\u00e9 sa n\u00e1m otvorilo, m\u00f4\u017eeme zad\u00e1va\u0165 jednotliv\u00e9 pr\u00edkazy. Na poslednom riadku vid\u00edme tzv. prompt : >>> . Ozna\u010duje, \u017ee program je pripraven\u00fd po\u010d\u00fava\u0165 na na\u0161e pr\u00edkazy. Dok\u00e1\u017ee napr. fungova\u0165 ako kalkula\u010dka, sta\u010d\u00ed hne\u010f za prompt nap\u00edsa\u0165 jednoduch\u00fd pr\u00edklad a stla\u010di\u0165 Enter . >>> 40 + 2 42 >>> 30 - 5 * 8 - 10 Znak * znamen\u00e1 n\u00e1sobenie. Vid\u00edme, \u017ee Python pozn\u00e1 z\u00e1kladn\u00e9 matematick\u00e9 pravidl\u00e1, najprv vypo\u010d\u00edtal n\u00e1sobenie, a\u017e potom od\u010d\u00edtanie. Ak by sme ho predsa len chceli presved\u010di\u0165, aby najprv od\u010d\u00edtal, pou\u017eijeme z\u00e1tvorky. Rovnako ako v matematike. S t\u00fdm rozdielom, \u017ee mus\u00edme pou\u017ei\u0165 okr\u00fahle z\u00e1tvorky () , tie ostatn\u00e9 ( []{} ) maj\u00fa pre Python in\u00fd v\u00fdznam a len by sme ho poplietli. >>> ( 30 - 5 ) * 8 200 Pozrime sa na delenie: >>> 40 / 5 8.0 >>> 40 // 5 8 >>> 40 / 7 5.714285714285714 >>> 40 // 7 5 V Pythone sa rozli\u0161uj\u00fa dva typy delenia: / je klasick\u00e9 delenie ako ho pozn\u00e1me, // je celo\u010d\u00edseln\u00e9 delenie . To znamen\u00e1, \u017ee v\u00fdsledkom je \u010d\u00edslo, ko\u013ekokr\u00e1t najviac sa zmest\u00ed delite\u013e do delenca cel\u00fd. 7 * 5 = 35 , v\u0161etko je e\u0161te v poriadku, ale 7 * 6 = 42 , a to je u\u017e viac ne\u017e 40, preto 40 // 7 = 5 . Pozn\u00e1mka Presnej\u0161ie, // je delenie / nasledovan\u00e9 zaokr\u00fahlen\u00edm nadol. Uk\u00e1\u017eeme si e\u0161te dve matematick\u00e9 \u0161peciality.","title":"Python ako kalkula\u010dka"},{"location":"01/#modulo","text":"Alebo inak: zvy\u0161ok po celo\u010d\u00edselnom delen\u00ed. Je to t\u00e1 \u010das\u0165, ktor\u00e1 n\u00e1m e\u0161te ch\u00fdba, ke\u010f pou\u017eijeme celo\u010d\u00edseln\u00e9 delenie // namiesto / . Pre t\u00fato oper\u00e1ciu sa pou\u017e\u00edva znak % . >>> 40 % 7 5 >>> 40 % 5 0 >>> 40 // 7 * 7 + 40 % 7 40 \u00daloha Pre\u010do posledn\u00fd pr\u00edklad vy\u0161iel pr\u00e1ve 40? Fungovalo by to aj s in\u00fdmi \u010d\u00edslami? Napr. s trojkou: >>> 3 // 7 * 7 + 3 % 7 Bude v\u00fdsledok 3? Plat\u00ed to pre v\u0161etky \u010d\u00edsla? Na poslednom pr\u00edklade sa v\u00e1m mo\u017eno nepozd\u00e1va, \u017ee sme nepou\u017eli \u017eiadne z\u00e1tvorky. Nemuseli sme, lebo n\u00e1sobenie, delenie aj modulo maj\u00fa rovnak\u00fa prioritu . S\u010d\u00edtanie a od\u010d\u00edtanie maj\u00fa od nich men\u0161iu prioritu, tak\u017ee sa vyhodnotia nesk\u00f4r. To u\u017e vieme, ke\u010f sme toto spr\u00e1vanie zmenili pou\u017eit\u00edm z\u00e1tvoriek. No a pri viacer\u00fdch oper\u00e1ciach rovnakej priority za sebou, Python ich vyhodnocuje z\u013eava doprava. Znovu ako v matematike. Tak\u017ee tento pr\u00edklad sa interpretuje akoby bol uz\u00e1tvorkovan\u00fd takto: >>> (( 40 // 7 ) * 7 ) + ( 40 % 7 ) 40","title":"Modulo"},{"location":"01/#mocnina","text":"Pripome\u0148me si, \u017ee mocnina je opakovan\u00e9 n\u00e1sobenie. 2 3 = 2 * 2 * 2 = 8 V Pythone pou\u017e\u00edvame na umoc\u0148ovanie oper\u00e1tor ** : >>> 2 ** 3 8 >>> 4 ** 1 4 >>> 1 ** 1000000000 1 >>> 5 ** 0 1 Umoc\u0148ovanie m\u00e1 e\u0161te v\u00e4\u010d\u0161iu prioritu ne\u017e n\u00e1sobenie. >>> 4 * 2 ** 3 32 >>> ( 4 * 2 ) ** 3 512 \u00daloha Ak\u00fd je v\u00fdsledok nasleduj\u00facich matematick\u00fdch v\u00fdrazov? Overte si spr\u00e1vnu odpove\u010f vyu\u017eit\u00edm Python IDLE. - 5 + 8 - (5 + 8) 2 % 4 - 1 10 // 3 ** 2 5 / -3 5 // -3 * 3 + 5 % -3","title":"Mocnina"},{"location":"01/#premenne","text":"Pri zlo\u017eitej\u0161\u00edch v\u00fdpo\u010dtoch si \u010dasto chceme ulo\u017ei\u0165 medziv\u00fdsledok. Modern\u00e9 kalkula\u010dky to zvl\u00e1dnu a Python IDLE tie\u017e! >>> x = 4 + 8 >>> x 12 >>> 2 * x 24 Pr\u00edkaz x = 4 + 8 znamen\u00e1 priradenie hodnoty na pravej strane ( 4 + 8 ) do premennej na \u013eavej strane ( x ). Najprv Python vypo\u010d\u00edta 4 + 8 . Potom si na miesto v pam\u00e4ti, kde m\u00e1 ulo\u017een\u00fd v\u00fdsledok, nalep\u00ed pozn\u00e1mku \"x\". Je to n\u00e1zov novej premennej, aby si pam\u00e4tal kam sa m\u00e1 pozrie\u0165, ke\u010f ju uvid\u00ed v na\u0161ich pr\u00edkazoch nabud\u00face. Napr. 2 * x -> 2 * 12 -> 24 . N\u00e1zvy m\u00f4\u017eu by\u0165 aj viacp\u00edsmenkov\u00e9, m\u00f4\u017eu obsahova\u0165 ve\u013ek\u00e9 aj mal\u00e9 znaky, tie\u017e cifry (ale cifra nem\u00f4\u017ee st\u00e1\u0165 na za\u010diatku mena) a podtr\u017e\u00edtko (\"_\"). \u010co sa stane ak budeme chcie\u0165 uk\u00e1za\u0165 hodnotu premennej, ktor\u00fa Python e\u0161te nepozn\u00e1? >>> y Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'y' is not defined V\u0161imnime si posledn\u00fd riadok. Hovor\u00ed n\u00e1m, \u017ee n\u00e1zov \"y\" nie je definovan\u00fd, in\u00fdmi slovami, nepozn\u00e1 ho, nevie kam sa pozrie\u0165. \u00daloha \u010co je v\u00fdsledkom nasleduj\u00facej postupnosti pr\u00edkazov? >>> a = 3 >>> b = 2 >>> a = a + b >>> b = a - b >>> a = a - b >>> a ? >>> b ? Aby sme si skratili z\u00e1pis, namiesto >>> a = a + b m\u00f4\u017eme pou\u017e\u00edva\u0165 >>> a += b V\u00fdznam je ten ist\u00fd. Rovnako existuje -= , *= , /= , //= , %= , **= . Vysk\u00fa\u0161ajte si pou\u017ei\u0165 niektor\u00e9 z nich.","title":"Premenn\u00e9"},{"location":"01/#tlacit","text":"V tejto \u010dasti si uk\u00e1\u017eeme nov\u00fd pr\u00edkaz. Vol\u00e1 sa \"print\". Z angli\u010dtiny vieme odhadn\u00fa\u0165, na \u010do bude sl\u00fa\u017ei\u0165. Vyp\u00ed\u0161e text na obrazovku. Zatia\u013e sme pracovali len s \u010d\u00edslami, e\u0161te nie z textom. V Pythone sa text p\u00ed\u0161e medzi \u00favodzovky (\"). Pozor! Ak nap\u00ed\u0161eme text bez \u00favodzoviek, interpretuje sa to ako n\u00e1zov, ktor\u00fd bude Python h\u013eada\u0165 a pravdepodobne dostaneme podobn\u00fa s\u0165a\u017enos\u0165 ako naposledy (hovor\u00ed sa im chybov\u00e9 hl\u00e1\u0161ky ). >>> print ( \"Ahoj\" ) Ahoj >>> print ( Ahoj ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > NameError : name 'Ahoj' is not defined Namiesto dvojit\u00fdch \u00favodzoviek sa daj\u00fa pou\u017ei\u0165 aj jednoduch\u00e9 ('). >>> print ( 'Cau' ) Cau Text s\u00edce nie je \u010d\u00edslo, ale v Pythone dok\u00e1\u017eeme text s\u010d\u00edtava\u0165 a dokonca aj n\u00e1sobi\u0165! >>> print ( 'Ahoj ' + 'Robo' + 'Lab' ) Ahoj RoboLab >>> print ( 'tra' + 'la' * 3 ) tralalala >>> print ( 3 + ' jablka' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unsupported operand type ( s ) for + : 'int' and 'str' S\u010d\u00edta\u0165 text a \u010d\u00edslo sa u\u017e ned\u00e1. To presne n\u00e1m povie chybov\u00e1 hl\u00e1\u0161ka na poslednom riadku: oper\u00e1tor + nefunguje s \u010d\u00edslom (ang. int eger) a textom (ang. character str ing). Ak potrebujeme vyp\u00edsa\u0165 v jednom pr\u00edkaze text a z\u00e1rove\u0148 aj \u010d\u00edslo, m\u00f4\u017eme ich oddeli\u0165 \u010diarkou. Python medzi ne automaticky vlo\u017e\u00ed medzeru. >>> pocet = 3 >>> print ( pocet ) 3 >>> print ( 'Mam' , pocet , 'jablka' ) Mam 3 jablka Tak\u017ee print funguje aj s \u010d\u00edslami, nielen textom! Pozor, m\u00f4\u017ee sa zda\u0165, \u017ee nasleduj\u00face riadky spravia to ist\u00e9, ale nie je to celkom tak. Za chv\u00ed\u013eu si o tom povieme viac. >>> 3 3 >>> print ( 3 ) 3","title":"Tla\u010di\u0165!"},{"location":"01/#nas-prvy-program","text":"Python IDLE obsahuje dve \u010dasti. Jednu z nich, pr\u00edkazov\u00fd riadok (tie\u017e shell ), sme pou\u017e\u00edvali doteraz. Sl\u00fa\u017ei na vykon\u00e1vanie jednotliv\u00fdch pr\u00edkazov, ale na\u0161e programy v bud\u00facnosti bud\u00fa omnoho dlh\u0161ie, pozost\u00e1vaj\u00fac z nieko\u013eko desiatok, aj stoviek riadkov. Tu n\u00e1m pom\u00f4\u017ee druh\u00e1 \u010das\u0165: editor . Otvor\u00edme ho cez \"File\" -> \"New\". Nap\u00ed\u0161me do\u0148 n\u00e1\u0161 prv\u00fd program: print ( 'Ahoj' , 'RoboLab' ) print ( 'RoboLab zdravi' ) Pou\u017e\u00edvame to, \u010do sme sa u\u017e nau\u010dili, ale tentokr\u00e1t nep\u00ed\u0161eme na\u0161e pr\u00edkazy do pr\u00edkazov\u00e9ho riadku a nevykonaj\u00fa sa hne\u010f. Ke\u010f chceme spusti\u0165 program, stla\u010d\u00edme kl\u00e1ves F5 . IDLE n\u00e1s vyzve aby sme si program ulo\u017eili a potom ho spust\u00ed v okne pr\u00edkazov\u00e9ho riadku. Mali by sme zbada\u0165 vyp\u00edsan\u00e9: Ahoj RoboLab RoboLab zdravi Vr\u00e1\u0165me sa teraz k probl\u00e9mu vypisovania \u010d\u00edsel. Ke\u010f spust\u00edme jednoduch\u00fd program, print ( 3 * 5 ) na v\u00fdstupe sa n\u00e1m zobraz\u00ed 15 . Sk\u00faste si to! Spr\u00e1vne, Python najprv vypo\u010d\u00edta \"3 * 5 = 15\" a n\u00e1sledne v\u00fdsledok pr\u00edkazom print vyp\u00ed\u0161e na obrazovku. Sk\u00fasme teraz spusti\u0165 program bez pr\u00edkazu print . 3 * 5 Na v\u00fdstupe sa n\u00e1m ni\u010d nezobraz\u00ed! Pre\u010do? Python znovu vyhodnot\u00ed \"3 * 5 = 15\", ale tento v\u00fdsledok sa strat\u00ed, nem\u00e1 \u017eiadny pr\u00edkaz, aby ho vyp\u00edsal. Pr\u00edkazov\u00fd riadok n\u00e1m v\u017edy aj uk\u00e1\u017ee v\u00fdsledok toho, \u010do mu zad\u00e1me. >>> 3 * 5 15 Ale ak chceme nie\u010do vyp\u00edsa\u0165 z programu , v\u017edy mus\u00edme pou\u017ei\u0165 pr\u00edkaz print ! Tip V uk\u00e1\u017ekach na t\u00fdchto str\u00e1nkach odl\u00ed\u0161ime pr\u00edkazov\u00fd riadok jednoducho: za\u010d\u00edna tromi v\u00e4\u010d\u0161\u00edtkami >>> . Ak tam nie s\u00fa, znamen\u00e1 to, \u017ee dan\u00e1 uk\u00e1\u017eka je program , a teda ho treba nap\u00edsa\u0165 do editoru.","title":"N\u00e1\u0161 prv\u00fd program"},{"location":"01/#preco-si-to-nezopakovat","text":"Doteraz bol Python celkom nudn\u00fd. Ke\u010f sme chceli, aby n\u00e1m nie\u010do nap\u00edsal, museli sme mu to sami nap\u00edsa\u0165 a e\u0161te k tomu naviac dop\u00edsa\u0165 \"print\". Na \u010do n\u00e1m je tak\u00fd Python? Uk\u00e1\u017eme si teda, \u017ee je silnej\u0161\u00ed, ne\u017e sa zd\u00e1. Spustite si tento program. Predposledn\u00e9 dva riadky za\u010d\u00ednaj\u00fa \u0161tyrmi medzerami a namiesto \u0161tyroch stla\u010den\u00ed medzern\u00edka m\u00f4\u017eeme pou\u017ei\u0165 kl\u00e1ves Tab . i = 0 while i < 3 : print ( 'tra' + 'la' * i ) i += 1 print ( 'koniec' ) Zd\u00e1 sa, \u017ee sme pou\u017eili nov\u00fd pr\u00edkaz: while . Aby sme mu porozumeli, mus\u00edme si najprv poveda\u0165 nie\u010do o ne/pravd\u00e1ch v Pythone.","title":"Pre\u010do si to nezopakova\u0165?"},{"location":"01/#logicke-ano-a-nie","text":"Presu\u0148me sa nachv\u00ed\u013eu znovu do pr\u00edkazov\u00e9ho riadku. Pracovali sme u\u017e s textov\u00fdmi a \u010d\u00edseln\u00fdmi hodnotami, teraz si uk\u00e1\u017eeme logick\u00e9 hodnoty (ang. boolean pod\u013ea matematika Georgea Boolea ). Existuj\u00fa len dve: True (pravda) a False (nepravda). V po\u010d\u00edta\u010doch je v\u0161etko jasn\u00e9, bu\u010f to je jednoducho pravdiv\u00e9 alebo nie je. >>> 1 < 2 True >>> 3 < - 5 False >>> 2 == 2 True >>> 2 >= 1 True >>> 2 >= 2 True M\u00e1me celkovo 6 porovn\u00e1vac\u00edch oper\u00e1torov : Oper\u00e1tor V\u00fdznam == rovn\u00e1 sa != nerovn\u00e1 sa < men\u0161ie ne\u017e <= men\u0161ie, nanajv\u00fd\u0161 rovn\u00e9 > v\u00e4\u010d\u0161ie ne\u017e >= v\u00e4\u010d\u0161ie, nanajv\u00fd\u0161 rovn\u00e9 Pozor! Ak chceme porovn\u00e1va\u0165, pou\u017e\u00edvame == (dva znaky \"=\"), ale ak prira\u010fujeme hodnotu do premennej, pou\u017e\u00edvame len = (jeden znak \"=\"). >>> a = 1 >>> a == 1 True Porovn\u00e1va\u0165 nemus\u00edme len \u010d\u00edsla: >>> 'text' != 'text' False >>> 2 == 'text' False >>> 2 == '2' False >>> 2 < 'text' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'str' >>> 'text' < 'text' False >>> 'a' < 'b' True >>> 'a' < 'aa' True >>> 'ab' <= 'aa' False Textov\u00e9 re\u0165azce sa porovn\u00e1vaj\u00fa lexikograficky . To znamen\u00e1, ak nejak\u00e9 slovo n\u00e1jdeme v abecednom zozname sk\u00f4r ne\u017e nejak\u00e9 druh\u00e9 slovo, tak to prv\u00e9 bude men\u0161ie. \u010c\u00edslo sa nikdy nebude rovna\u0165 \u017eiadnemu textu a dokonca na men\u0161ie/va\u010d\u0161ie sa ani nem\u00f4\u017eeme sp\u00fdta\u0165. >>> False == False True >>> False == 0 True >>> True == 1 True >>> False < True True Logick\u00e9 hodnoty sa spr\u00e1vaj\u00fa ako \u010d\u00edsla, pri\u010dom False je nula a True jednotka. >>> True + True 2 >>> True * False 0 V Pythone m\u00e1 ka\u017ed\u00e1 premenn\u00e1 (a ka\u017ed\u00e1 hodnota) nejak\u00fd typ ( d\u00e1tov\u00fd typ ). Dok\u00e1\u017eeme ho zisti\u0165 pomocou pr\u00edkazu type : >>> type ( 3 ) < class ' int '> >>> type ( 'text' ) < class ' str '> >>> type ( True ) < class ' bool '> >>> a = False >>> type ( a ) < class ' bool '> S presn\u00fdm v\u00fdznamom slov\u00ed\u010dka class si zatia\u013e nebudeme l\u00e1ma\u0165 hlavu, sta\u010d\u00ed si zapam\u00e4ta\u0165, \u017ee ka\u017ed\u00e1 hodnota m\u00e1 nejak\u00fd jednozna\u010dn\u00fd typ.","title":"Logick\u00e9 \u00e1no a nie"},{"location":"01/#prikaz-while","text":"Teraz u\u017e budeme vedie\u0165 pou\u017ei\u0165 pr\u00edkaz while (naz\u00fdva sa tie\u017e cyklus ): while \"podmienka\" : \"pr\u00edkaz 1\" \"pr\u00edkaz 2\" ... \"pr\u00edkaz 3\" ... \"while\" znamen\u00e1 po anglicky \"pok\u00fdm\". A tak mu Python aj rozumie. Pok\u00fdm je \"podmienka\" pravdiv\u00e1, teda True , tak bude postupne vykon\u00e1va\u0165 \"pr\u00edkaz 1\", \"pr\u00edkaz 2\", ..., v\u0161etko, \u010do je odsaden\u00e9 o \u0161tyri medzery vpravo (t\u00fdmto pr\u00edkazom hovor\u00edme telo cyklu ). Ke\u010f pr\u00edde na koniec, znovu sa sp\u00fdta, \u010di je \"podmienka\" pravdiv\u00e1, ak \u00e1no, vykon\u00e1 znovu telo cyklu. A tak st\u00e1le dokola. Ke\u010f u\u017e \"podmienka\" pravdiv\u00e1 nebude, Python sko\u010d\u00ed na \"pr\u00edkaz 3\" a pokra\u010duje \u010falej. Vysk\u00fa\u0161ajme si spravi\u0165 nekone\u010dn\u00fd cyklus. Nap\u00ed\u0161eme tak\u00fdto jednoduch\u00fd program: while 1 == 1 : print ( 'ahoj' ) Spust\u00edme, a ke\u010f\u017ee 1 == 1 sa v\u017edy vyhodnot\u00ed na True , tak m\u00e1me cel\u00fa obrazovku \"ahoj\"ov. Program m\u00f4\u017eme zastavi\u0165 kl\u00e1vesovou kombin\u00e1ciou Ctrl+C. Rovnako by sme mohli nap\u00edsa\u0165: while True : print ( 'ahoj' ) \u00daloha \u010co vyp\u00ed\u0161e nasleduj\u00faci program? while False : print ( 'ahoj' ) print ( 'koniec' ) Najprv sk\u00faste na to pr\u00eds\u0165 sami, odpove\u010f si potom overte spusten\u00edm. Vieme u\u017e dos\u0165 na to, aby sme si nap\u00edsali trochu zauj\u00edmavej\u0161\u00ed program. Budeme \"kresli\u0165\" trojuholn\u00edky z hviezdi\u010diek (*). Od teraz budeme p\u00edsa\u0165 zdrojov\u00fd k\u00f3d po anglicky. Nebud\u00fa sa n\u00e1m mie\u0161a\u0165 slovensk\u00e9 a anglick\u00e9 slov\u00e1 (napr. print ( 'jablko' ) ), a ke\u010f vytvor\u00edme nejak\u00fd \u00fa\u017easn\u00fd program, budeme sa m\u00f4c\u0165 o\u0148 podeli\u0165 s cel\u00fdm svetom! Ako chceme aby vyzerali trojuholn\u00edky z hviezdi\u010diek? Najmen\u0161\u00ed trojuholn\u00edk ve\u013ekosti 1 je jednoduch\u00fd: * Ve\u013ekos\u0165 dva: ** * Ve\u013ekos\u0165 4: **** *** ** * U\u017e m\u00e1me predstavu, \u010do chceme naprogramova\u0165, tak\u017ee pustime sa do toho. Potrebujeme vedie\u0165, ak\u00fd ve\u013ek\u00fd trojuholn\u00edk chceme. size = 3 Vid\u00edme, \u017ee trojuholn\u00edk je nakreslen\u00fd na to\u013eko isto riadkov ak\u00e1 je jeho ve\u013ekos\u0165. size = 3 while size > 0 : # print one row size -= 1 Na miesto # print one row nap\u00ed\u0161eme k\u00f3d, ktor\u00fd to vykon\u00e1, zatia\u013e sme si to len pozna\u010dili. Tak\u00e1to \u010das\u0165 v zdrojovom k\u00f3de sa naz\u00fdva koment\u00e1r . Za\u010d\u00edna sa znakom \"#\" a pokra\u010duje a\u017e do konca riadku. Koment\u00e1re Python ignoruje, s\u00fa to pozn\u00e1mky n\u00e1s, program\u00e1torov. Ak by sme \u00favodn\u00fd \"#\" nepou\u017eili, Python by sa sna\u017eil interpretova\u0165 dan\u00fd riadok ako pr\u00edkaz a skon\u010dil by s chybovou hl\u00e1\u0161kou. Pozrime sa na to, ako sme pou\u017eili premenn\u00fa \"size\" v podmienke cyklu. Na za\u010diatku programu sa nastav\u00ed na hodnotu 3. Podmienka size > 0 sa vyhodnot\u00ed na True a telo cyklu sa vykon\u00e1. V \u0148om m\u00e1me pr\u00edkaz size -= 1 . Tak\u017ee teraz u\u017e plat\u00ed \"size = 2\". Znovu pr\u00edde na podmienku cyklu, \"2 > 0\", a teda telo cyklu sa vykon\u00e1, \"size\" sa zn\u00ed\u017ei o jedna, na hodnotu 1. Podmienka je znovu vyhodnoten\u00e1 ako True , \"size\" sa zn\u00ed\u017ei na hodnotu 0. Teraz u\u017e podmienka splnen\u00e1 nie je a telo cyklu sa nezopakuje. Celkovo sa teda cyklus zopakoval 3 kr\u00e1t. Presne to sme chceli! Zost\u00e1va n\u00e1m v ka\u017edom opakovan\u00ed vykresli\u0165 jeden riadok. Na prvom riadku chceme ma\u0165 3 hviezdi\u010dky. Na druhom 2 a na poslednom jednu. size = 3 while size > 0 : print ( '*' * size ) size -= 1 Hur\u00e1 a je to! Teraz sta\u010d\u00ed zmeni\u0165 v prvom riadku \"size\" na ve\u013ekos\u0165 ak\u00fa chceme a Python n\u00e1m vykresl\u00ed \u017eiadan\u00fd trojuholn\u00edk. Vysk\u00fa\u0161ajte si r\u00f4zne ve\u013ekosti. \u00daloha 1 Nap\u00ed\u0161te program podobn\u00fd tomu posledn\u00e9mu, ktor\u00fd bude kresli\u0165 \u0161tvorce. \u00daloha 2 Nap\u00ed\u0161te program kresliaci trojuholn\u00edky, ale naopak ako doteraz. Teda, pre ve\u013ekos\u0165 4 bude vyzera\u0165: * ** *** **** Toto je u\u017e trochu \u0165a\u017e\u0161ia \u00faloha, vy\u017eaduje pou\u017ei\u0165 a\u017e dve premenn\u00e9. \"size\" sa tentokr\u00e1t meni\u0165 nebude, ale druh\u00e1 premenn\u00e1 bude ma\u0165 postupne hodnoty od 1 a\u017e po \"size\", tak\u017ee budete vedie\u0165 jednoducho vykresli\u0165 hviezdi\u010dky na ka\u017edom riadku pod\u013ea nej. Premyslite si to dobre. \u00daloha 3 Nap\u00ed\u0161te program, ktor\u00fd vykresl\u00ed obd\u013a\u017enik. Na za\u010diatku bud\u00fa teda dve premenn\u00e9: jedna pre ve\u013ekos\u0165 ka\u017edej strany. \u00daloha 4 Pozor, toto je ve\u013emi tvrd\u00fd orie\u0161ok! Nap\u00ed\u0161te program, tentokr\u00e1t kresliaci pyram\u00eddu. Tu s\u00fa vzory pre ve\u013ekosti 1, 2 a 4: * * *** * *** ***** *******","title":"Pr\u00edkaz while"},{"location":"02/","text":"Python: vstup, riadiace \u0161trukt\u00fary, zoznam Dnes si uk\u00e1\u017eeme ako v programe aj \u010d\u00edta\u0165, nielen vypisova\u0165 na obrazovku, uk\u00e1\u017eeme si viac pr\u00edkazov podobn\u00fdch while u a nov\u00fd, zlo\u017eitej\u0161\u00ed, d\u00e1tov\u00fd typ. Na\u010d\u00edtanie vstupu Pripome\u0148me si n\u00e1\u0161 program na kreslenie trojuholn\u00edkov: size = 3 while size > 0 : print ( '*' * size ) size -= 1 Na to, aby sme zmenili ve\u013ekos\u0165, v\u017edy znovu a znovu mus\u00edme prep\u00edsa\u0165 n\u00e1\u0161 zdrojov\u00fd k\u00f3d. Bolo by pekn\u00e9, ke\u010f by sme mali len jeden program, ten spust\u00edme a sp\u00fdta sa n\u00e1s na ve\u013ekos\u0165, ak\u00fa m\u00e1 pou\u017ei\u0165. Tomu sa hovor\u00ed na\u010d\u00edtanie vstupu a sl\u00fa\u017ei na to pr\u00edkaz input . Po\u010fme si ho vysk\u00fa\u0161a\u0165 v pr\u00edkazovom riadku: >>> input () hello 'hello' >>> input ( 'Enter Your name: ' ) Enter Your name : robot 'robot' Po zadan\u00ed pr\u00edkazu input() , shell \u010dak\u00e1, pok\u00fdm zad\u00e1me nejak\u00fd text a stla\u010d\u00edme Enter . Potom vyp\u00ed\u0161e v\u00fdsledok (rovnako ako ke\u010f sme vyu\u017e\u00edvali Python na r\u00e1tanie pr\u00edkladov) -- v\u00fdsledkom pr\u00edkazu input() je v tomto pr\u00edpade text 'hello'. Ke\u010f medzi z\u00e1tvorky vp\u00ed\u0161eme text, pou\u017eije tento text ako prompt. Vyp\u00ed\u0161e ho a znovu \u010dak\u00e1 na n\u00e1s, aby sme mu nie\u010do nap\u00edsali. V\u00fdsledok input() u si m\u00f4\u017eme ulo\u017ei\u0165 do premennej: >>> year = input ( 'Favorite year? ' ) Favorite year ? 1965 >>> year '1965' Vylep\u0161enie kresli\u010da Na\u010d\u00edtanie ve\u013ekosti cez input() je jednoduch\u00e9... size = input ( 'Enter size: ' ) while size > 0 : print ( '*' * size ) size -= 1 ...alebo nie? Dok\u00e1\u017eete zisti\u0165 z chybovej hl\u00e1\u0161ky, \u010do sa stalo? Pri porovn\u00e1van\u00ed size > 0 sa Pythonu nep\u00e1\u010di, \u017ee porovn\u00e1vame 'str' a 'int', teda text a \u010d\u00edslo. Tak\u017ee premenn\u00e1 \"size\" m\u00e1 typ 'str'. Pozrime sa na to v shelli: >>> a = input () 1 >>> type ( a ) < class ' str '> Naozaj, v\u00fdsledkom input() u je text. My potrebujeme tento text konvertova\u0165 na \u010d\u00edslo, na pomoc n\u00e1m pr\u00edde \u010fal\u0161\u00ed pr\u00edkaz -- int() : >>> int ( '32' ) 32 >>> int ( '-1' ) - 1 >>> int ( 42 ) 42 >>> int ( '4.2' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : invalid literal for int () with base 10 : '4.2' >>> int ( 'd4' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : invalid literal for int () with base 10 : 'd4' >>> int ( 4.2 ) 4 >>> int ( False ) 0 Tento pr\u00edkaz sa sna\u017e\u00ed hociak\u00fa hodnotu previes\u0165 na cel\u00e9 \u010d\u00edslo. Ke\u010f sa to ned\u00e1, skon\u010d\u00ed s chybou. Desatinn\u00e9 \u010d\u00edslo 4.2 prevedie tak, \u017ee desatinn\u00fa \u010das\u0165 jednoducho zahod\u00ed. Ale text 4.2 nevie konvertova\u0165. Na to by sme najprv museli previes\u0165 text do desatinn\u00e9ho \u010d\u00edsla a potom do cel\u00e9ho: >>> int ( float ( '4.2' ) ) 4 \u00daloha Pre ka\u017ed\u00fd datov\u00fd typ, ktor\u00fd pozn\u00e1me, existuje tak\u00e1to konvertovacia funkcia: int , float , str , bool . Vysk\u00fa\u0161ajte si napr. konvertova\u0165 \u010d\u00edslo na 'bool' alebo previes\u0165 \u010d\u00edslo na text a potom zase sp\u00e4\u0165 na \u010d\u00edslo. N\u00e1\u0161 opraven\u00fd program teda vyzer\u00e1: size = int ( input ( 'Enter size: ' ) ) while size > 0 : print ( '*' * size ) size -= 1 V\u00fdsledok z input() , \u010do je text, vhod\u00edme do pr\u00edkazu int() , a dostaneme v\u00fdsledok ako cel\u00e9 \u010d\u00edslo, ktor\u00e9 u\u017e m\u00f4\u017eme pou\u017ei\u0165 na porovnanie, od\u010d\u00edtanie aj n\u00e1sobenie. Probl\u00e9m je, ak zad\u00e1me text, ktor\u00fd sa ned\u00e1 konvertova\u0165 na \u010d\u00edslo. Tento probl\u00e9m sa d\u00e1 vyrie\u0161i\u0165, my to zatia\u013e nevieme, ale nie je to tak\u00e9 d\u00f4le\u017eit\u00e9. Ak chce niekto pou\u017e\u00edva\u0165 n\u00e1\u0161 program, tak m\u00e1 vedie\u0165, ako p\u00edsa\u0165 \u010d\u00edsla! \u00daloha 1 Nap\u00ed\u0161te program, ktor\u00fd sa sp\u00fdta pou\u017e\u00edvate\u013ea na meno a n\u00e1sledne ho pozdrav\u00ed. Beh programu potom m\u00f4\u017ee vyzera\u0165 napr\u00edklad takto: What's Your name? Kubko Hello Kubko! \u00daloha 2 Vytvorte program, ktor\u00fd si vy\u017eiada rok narodenia a vyp\u00ed\u0161e, ko\u013ekat\u00e9 narodeniny m\u00e1 dan\u00fd \u010dlovek v s\u00fa\u010dasnom roku. Podmienen\u00fd pr\u00edkaz Jeden probl\u00e9m s na\u0161im kresli\u010dom trojuholn\u00edkov ale predsa len vyrie\u0161ime. Ke\u010f si teraz niekto pust\u00ed n\u00e1\u0161 program a zad\u00e1 ve\u013ekos\u0165 \"-3\", program ni\u010d nevyp\u00ed\u0161e, len ticho skon\u010d\u00ed (overte si to). Bolo by pekn\u00e9 pou\u017e\u00edvate\u013ea informova\u0165 o tom, \u017ee mus\u00ed zada\u0165 nez\u00e1porn\u00fa ve\u013ekos\u0165. Potrebujeme otestova\u0165, \u010di plat\u00ed size < 0 , na to vyu\u017eijeme podmienen\u00fd pr\u00edkaz if . Pozrime sa na nasleduj\u00faci program (spustite si ho): if 1 < 2 : print ( '1 < 2' ) if 2 < 1 : print ( 'Python is wrong' ) else : print ( 'Python is right' ) Anglick\u00e9 slov\u00ed\u010dko \"if\" znamen\u00e1 \"ak\" a \"else\" znamen\u00e1 \"inak\". Tak\u017ee, ke\u010f si pre\u010d\u00edtame zdrojov\u00fd k\u00f3d, hne\u010f vieme, ako tento nov\u00fd pr\u00edkaz (presnej\u0161ie, riadiaca \u0161trukt\u00fara ) funguje. Ak 1 je menej ne\u017e 2, nap\u00ed\u0161 \"1 < 2\". Ak 2 < 1, nap\u00ed\u0161 \"Python is wrong\", inak nap\u00ed\u0161 \"Python is right\". V\u0161imnime si, \u017ee na konci riadku s if alebo else je v\u017edy dvojbodka. Rovnako sme ju tam p\u00edsali, ke\u010f sme pou\u017e\u00edvali while . Ozna\u010duje, \u017ee nieko\u013eko \u010fal\u0161\u00edch riadkov bude odsaden\u00fdch o \u0161tyri medzeri vpravo a maj\u00fa sa bra\u0165 ako jeden blok k\u00f3du. V\u0161imnime si rozdiel v t\u00fdchto dvoch programoch: if False : print ( 'A' ) print ( 'B' ) if False : print ( 'A' ) print ( 'B' ) Ke\u010f ich spust\u00edme, ka\u017ed\u00fd vykon\u00e1 nie\u010do in\u00e9. Python je ve\u013emi h\u00e1kliv\u00fd na medzery na za\u010diatku riadku. V podstate je jedno, ko\u013eko ich tam bude, ale v\u017edy, ak m\u00e1 by\u0165 nejak\u00fd blok k\u00f3du odsaden\u00fd vpravo (teda v\u017edy za dvojbodkou), nejak\u00e1 medzera tam mus\u00ed by\u0165 a treba tento po\u010det dodr\u017eiava\u0165. Obydva nasleduj\u00face programy skon\u010dia s chybou (sk\u00faste si ich spusti\u0165): if False : print ( 'A' ) if False : print ( 'A' ) print ( 'A' ) Prv\u00fd z nich nem\u00e1 blok odsaden\u00fd v\u00f4bec, druh\u00fd nepou\u017e\u00edva po\u010det medzier konzistentne. Je be\u017en\u00e9 odsadzova\u0165 bloky v\u017edy o 4 medzery, a tak to budeme robi\u0165 aj my. elif K pr\u00edkazom if , else , e\u0161te existuje tret\u00ed kamar\u00e1t: elif . Znamen\u00e1 nie\u010do ako \"inak, ak ...\". Uk\u00e1\u017eeme si jeho pou\u017eitie, z ktor\u00e9ho to bude najlep\u0161ie vidie\u0165. grade = input () if grade == 'A' : print ( 'Excellent!' ) elif grade == 'B' : print ( 'Good' ) elif grade == 'C' : print ( 'Not bad' ) elif grade == 'D' : print ( 'You could do better' ) else : print ( 'I know only four grades: A, B, C, D' ) Python najprv otestuje, \u010di pou\u017e\u00edvate\u013e zadal p\u00edsmeno \"A\", ak nie, otestuje \"B\", at\u010f., ak nie ani \"D\", vykon\u00e1 posledn\u00fd blok k\u00f3du. \u00daloha Sk\u00faste e\u0161te vylep\u0161i\u0165 kresli\u010da tak, \u017ee ak u\u017e\u00edvate\u013e zad\u00e1 z\u00e1porn\u00e9 \u010d\u00edslo, nap\u00ed\u0161e mu, \u017ee mus\u00ed zada\u0165 kladn\u00e9 (alebo nulu). Ak zad\u00e1 v\u00e4\u010d\u0161ie \u010d\u00edslo ne\u017e 10, vyp\u00ed\u0161e spr\u00e1vu otom, \u017ee je to pr\u00edli\u0161 ve\u013ea a mal by po\u017eiada\u0165 o men\u0161iu ve\u013ekos\u0165. Ak ani jeden z t\u00fdchto scen\u00e1rov sa nestane, tak potom program vykresl\u00ed trojuholn\u00edk. Pou\u017eite na to pr\u00edkazy if , elif a else . Mal\u00e1 rada: odsaden\u00fd m\u00f4\u017ee (dokonca mus\u00ed) by\u0165 aj u\u017e odsaden\u00fd k\u00f3d. Napr\u00edklad nasleduj\u00faci zdrojov\u00fd k\u00f3d je validn\u00fd: if 1 == 1 : if 2 == 2 : print ( '1 == 1 and 2 == 2' ) Logick\u00e9 oper\u00e1tory U\u017e pozn\u00e1me logick\u00e9 hodnoty: False a True . Vieme, \u017ee v\u00fdsledkom porovn\u00e1vac\u00edch oper\u00e1torov s\u00fa pr\u00e1ve tieto hodnoty. Ale \u010do ak potrebujeme otestova\u0165 dve podmienky naraz? Napr. \"Ak vonku pr\u0161\u00ed a je pondelok, nep\u00f4jdem do \u0161koly\". M\u00f4\u017eeme tak\u00fd program nap\u00edsa\u0165 pomocou dvoch pr\u00edkazov if : if wheather == 'raining' : if weekday == 'monday' : go_to_school = False Teraz si uk\u00e1\u017eeme 3 logick\u00e9 oper\u00e1tory, ktor\u00e9 n\u00e1m pom\u00f4\u017eu nap\u00edsa\u0165 aj zlo\u017eitej\u0161ie podmienky v jednom if e. A z\u00e1rove\u0148 if a and b : ... a b V\u00fdsledok True True True True False False False True False False False False Alebo if a or b : ... a b V\u00fdsledok True True True True False True False True True False False False Z\u00e1por if not a : ... a V\u00fdsledok True False False True Pou\u017eitie Nieko\u013eko pr\u00edpadov pou\u017eitia si uk\u00e1\u017eeme v shelli: >>> ( 1 < 2 ) and ( 3 < 4 ) True >>> 'A' == 'B' or 1 != 2 True >>> 1 == 2 or 2 == 1 False >>> not 4 > 5 True >>> False or not 1 >= 1 False Z\u00e1tvorky pou\u017ei\u0165 m\u00f4\u017eeme, ale ke\u010f\u017ee porovn\u00e1vacie oper\u00e1tory maj\u00fa vy\u0161\u0161iu prioritu ako logick\u00e9, vyhodnotia sa e\u0161te pred nimi, a teda to nie je nutn\u00e9. Neodbytnej\u0161\u00ed kresli\u010d Uprav\u00edme teraz kresli\u010da trojuholn\u00edkov tak, aby v pr\u00edpade nevalidnej ve\u013ekosti neskon\u010dil hne\u010f, ale bol neodbytn\u00fd a p\u00fdtal sa na ve\u013ekos\u0165, pok\u00fdm nejak\u00fa nedostane (alebo nebude nakoniec v z\u00farivosti vypnut\u00fd pomocou Ctrl + C ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 done = False while not done : size = int ( input ( 'Enter size: ' ) ) if size < 0 or size > 10 : print ( 'Error!' ) if size < 0 : print ( 'We need a non-negative size' ) elif size > 10 : print ( 'This is too much. We accept at most size of 10.' ) else : done = True while size > 0 : print ( '*' * size ) size -= 1 Prejdime si zdrojov\u00fd k\u00f3d riadok za riadkom: 1 done = False V tejto premennej si budeme uchov\u00e1va\u0165 inform\u00e1ciu o tom, \u010di sa n\u00e1m u\u017e podarilo na\u010d\u00edta\u0165 validn\u00fd vstup (ve\u013ekos\u0165). Na za\u010diatku programu rozhodne e\u0161te \u017eiaden vstup od u\u017e\u00edvate\u013ea nem\u00e1me, preto nastav\u00edme done na False . 3 4 while not done : size = int ( input ( 'Enter size: ' ) ) Toto je hlavn\u00fd cyklus na\u010d\u00edtavania ve\u013ekosti. Pok\u00fdm nebudeme ma\u0165 pozna\u010den\u00e9 v done , \u017ee u\u017e sme na\u010d\u00edtali dobr\u00fd vstup, cyklus sa bude opakova\u0165. Sp\u00f4sob na\u010d\u00edtania u\u017e pozn\u00e1me. 6 7 8 9 10 11 12 if size < 0 or size > 10 : print ( 'Error!' ) if size < 0 : print ( 'We need a non-negative size' ) elif size > 10 : print ( 'This is too much. We accept at most size of 10.' ) Otestujeme, \u010di je ve\u013ekos\u0165 validn\u00e1. Ak nie, nap\u00ed\u0161eme pou\u017e\u00edvate\u013eovi, \u017ee nie\u010do je zle a potom aj \u010cO je zle. 13 14 else : done = True Ak je v\u0161etko OK, pozna\u010d\u00edme si, \u017ee sa n\u00e1m podarilo na\u010d\u00edta\u0165 ve\u013ekos\u0165, a tak pri \u010fal\u0161om testovan\u00ed podmienky cyklu, v\u00fdraz not done sa vyhodnot\u00ed na False a program bude pokra\u010dova\u0165 za while cyklom. 16 17 18 while size > 0 : print ( '*' * size ) size -= 1 Tu sa ni\u010d nezmenilo, tak ako aj doteraz, vykresl\u00edme trojuholn\u00edk. \u00daloha Vytvorte program, ktor\u00fd nech\u00e1 pou\u017e\u00edvate\u013ea h\u00e1da\u0165, ak\u00e9 \u010d\u00edslo si mysl\u00ed po\u010d\u00edta\u010d. Vyzera\u0165 by to mohlo podobne ako: Let's play a game: Guess the number I've chosen (1..100 inclusive) Your guess: 12 Try a greater number Your guess: 50 Try a lower number Your guess: 45 Try a lower number Your guess: 42 Congratulation! Pozn\u00e1mka: Vytvori\u0165 v programe n\u00e1hodn\u00e9 \u010d\u00edslo e\u0161te nevieme, zatia\u013e k\u013eudne m\u00f4\u017ee by\u0165 toto \u010d\u00edslo priamo nap\u00edsan\u00e9 v zdrojovom k\u00f3de a ulo\u017een\u00e9 v premennej na za\u010diatku k\u00f3du. number = 42 # Main program logic follows... Zoznam Zopakujme si, ak\u00e9 d\u00e1tov\u00e9 typy pozn\u00e1me: cel\u00e9 \u010d\u00edsla - 'int' desatinn\u00e9 \u010d\u00edsla - 'float' textov\u00fd re\u0165azec - 'str' logick\u00e1 hodnota - 'bool' Teraz si do tohto zoznamu prid\u00e1me \u010fal\u0161\u00ed: zoznam - 'list' Ako aj n\u00e1zov napoved\u00e1, do zoznamu si budeme uklada\u0165 viacero hodn\u00f4t. Je to vlastne postupnos\u0165 \u010d\u00edsel, textu, logick\u00fdch hodn\u00f4t, ..., dokonca aj samotn\u00fdch zoznamov. Aby sme vytvorili zoznam hodn\u00f4t, vp\u00ed\u0161eme ich medzi hranat\u00e9 z\u00e1tvorky. >>> [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ] >>> [ 1 , False , 3 , 'ABCD' , 5 , [ 4.2 , [] ] ] [ 1 , False , 3 , 'ABCD' , 5 , [ 4.2 , []]] >>> type ( [ 1 , False , 'ABC' ] ) < class ' list '> Hodnoty ulo\u017een\u00e9 v zozname naz\u00fdvame prvky a pristupujeme k nim cez index . Index je poradie prvku od za\u010diatku zoznamu, pri\u010dom prv\u00fd prvok m\u00e1 index 0. Na indexovanie pou\u017e\u00edvame hranat\u00e9 z\u00e1tvorky. >>> l = [ 1 , False , 3 , 'ABCD' , 5 , [ 4.2 , [] ] ] >>> l [ 0 ] 1 >>> l [ 1 ] False >>> l [ 5 ] [ 4.2 , []] >>> l [ 5 ][ 1 ] [] >>> l [ - 1 ] [ 4.2 , []] >>> l [ - 2 ] 5 >>> l [ 6 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > IndexError : list index out of range Indexy m\u00f4\u017eu by\u0165 aj z\u00e1porn\u00e9, vtedy ozna\u010duje poradie odzadu. No pozor na pr\u00edli\u0161 vysok\u00e9 indexy. Ak chceme prist\u00fapi\u0165 k prvku za koncom zoznamu, dostaneme chybov\u00fa hl\u00e1\u0161ku. Prvky v zozname m\u00f4\u017eeme aj upravova\u0165: >>> l [ 1 ] = 2 >>> l [ 1 , 2 , 3 , 'ABCD' , 5 , [ 4.2 , []]] A pr\u00edpadne cel\u00fd zoznam vieme pred\u013a\u017ei\u0165. Existuje viacero sp\u00f4sobov: >>> l = [ 1 , 2 ] >>> l . append ( 3 ) >>> l [ 1 , 2 , 3 ] >>> l . extend ( [ 4 , 5 , 5 ] ) >>> l [ 1 , 2 , 3 , 4 , 5 , 5 ] >>> l + [ 0 ] [ 1 , 2 , 3 , 4 , 5 , 5 , 0 ] >>> l [ 1 , 2 , 3 , 4 , 5 , 5 ] >>> l += [ 0 ] >>> l [ 1 , 2 , 3 , 4 , 5 , 5 , 0 ] Oper\u00e1tor + vytvor\u00ed nov\u00fd zoznam z p\u00f4vodn\u00fdch dvoch -- tieto dva zostan\u00fa nezmenen\u00e9. Ak chceme zoznam pred\u013a\u017ei\u0165, a teda naozaj ho zmeni\u0165, mus\u00edme na to pou\u017ei\u0165 oper\u00e1tor += . A vieme ho zase skr\u00e1ti\u0165: >>> l . pop () 0 >>> l [ 1 , 2 , 3 , 4 , 5 , 5 ] >>> a = l . pop () >>> a 5 >>> l [ 1 , 2 , 3 , 4 , 5 ] >>> del l [ 1 ] >>> l [ 1 , 3 , 4 , 5 ] pop() zma\u017ee posledn\u00fd prvok, ktor\u00fd si z\u00e1rove\u0148 m\u00f4\u017eeme niekam ulo\u017ei\u0165. del vyma\u017ee \u013eubovo\u013en\u00fd prvok na danom indexe. Uk\u00e1\u017eme si, \u010do e\u0161te vieme so zoznamom robi\u0165: >>> l . reverse () # obr\u00e1ti zoznam >>> l [ 5 , 4 , 3 , 1 ] >>> l . clear () # vyma\u017ee v\u0161etky prvky >>> l [] >>> l = [ 1 ] >>> l . insert ( 0 , 8 ) # vlo\u017e\u00ed prvok 8 na index 0 >>> l [ 8 , 1 ] >>> l . insert ( 1 , 9 ) >>> l [ 8 , 9 , 1 ] >>> l . remove ( 8 ) # odstr\u00e1ni prv\u00fd v\u00fdskit prvku 8 >>> l [ 9 , 1 ] >>> l . remove ( 0 ) # ak dan\u00fd prvok neexistuje, chyba Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : list . remove ( x ): x not in list >>> l = [ 1 , 4 , 4 , 9 , 2 , 0 , 3 , 4 ] >>> l . count ( 1 ) # spo\u010d\u00edta po\u010det v\u00fdskitov prvku 1 >>> l . count ( 4 ) 3 >>> l . count ( 42 ) 0 >>> l . sort () # zorad\u00ed zoznam >>> l [ 0 , 1 , 2 , 3 , 4 , 4 , 4 , 9 ] >>> l . index ( 4 ) # vr\u00e1ti index prv\u00e9ho v\u00fdskitu prvku 4 >>> l . index ( 5 ) # chyba, podobne ako pri 'remove' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : 5 is not in list >>> len ( l ) # zist\u00ed d\u013a\u017eku (po\u010det prvkov) zoznamu 8 >>> len ( [ 'robo' , 'lab' ] ) 2 >>> len ( [] ) 0 >>> 3 in [ 2 , 3 , 1 ] # test na pr\u00edtomnos\u0165 prvku v zozname True >>> 1 in [ 4 , 5 ] False >>> 'l' in 'hello' True >>> 0 in [] False Priemer \u010d\u00edsel Aby sme si uk\u00e1zali pr\u00edklad vyu\u017eitia zoznamu, vytvor\u00edme program, ktor\u00fd vypo\u010d\u00edta priemer \u010d\u00edsel zadan\u00fdch pou\u017e\u00edvate\u013eom. Tie si budeme uklada\u0165 do zoznamu. Ako budeme ale vedie\u0165, kedy u\u017e\u00edvate\u013e u\u017e nap\u00edsal v\u0161etky \u010d\u00edsla? D\u00e1me mu mo\u017enos\u0165 to ozn\u00e1mi\u0165 napr. t\u00fdm, \u017ee zad\u00e1 text \"end\". 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 print ( 'I \\' ll compute the mean value of all the entered numbers.' ) print ( 'Type \"end\" after entering all of them.' ) done = False numbers = [] while not done : number = input ( 'Enter a number (or \"end\"): ' ) if number == 'end' : done = True else : numbers . append ( int ( number ) ) print ( 'Entered numbers:' , numbers ) Na za\u010diatku u\u017e\u00edvate\u013ea informujeme o tom ako pou\u017e\u00edva\u0165 n\u00e1\u0161 program. V\u0161imnime si, \u017ee na to, aby sme vyp\u00edsali jednoduch\u00fa \u00favodzovku, mus\u00edme pred \u0148u nap\u00edsa\u0165 \u0161peci\u00e1lny znak sp\u00e4tn\u00e9 lom\u00edtko (\\). Je to preto, lebo \u00favodzovkami sa ozna\u010duje za\u010diatok a koniec textov\u00e9ho re\u0165azca. Ak by sme nepou\u017eili sp\u00e4tn\u00e9 lom\u00edtko, Python by ako text pochopil iba \"I\" a dostali by sme chybu. Vstup na\u010d\u00edtame najprv ako text, aby sme mohli otestova\u0165 koniec zad\u00e1vania \u010d\u00edsel, a ke\u010f ten nenastane, konvertujeme ho na cel\u00e9 \u010d\u00edslo a prid\u00e1me do zoznamu. Na konci vyp\u00ed\u0161eme v\u0161etky \u010d\u00edsla z ktor\u00fdch budeme r\u00e1ta\u0165 priemer. 1 2 3 4 5 6 7 8 i = 0 summ = 0 while i < len ( numbers ): summ += numbers [ i ] i += 1 print ( 'Mean:' , summ / len ( numbers ) ) Aby sme vypo\u010d\u00edtali priemer, najprv pomocou cyklu s\u010d\u00edtame v\u0161etky \u010d\u00edsla. Premenn\u00e1 i m\u00e1 na za\u010diatku hodnotu nula, teda index prv\u00e9ho prvu. Postupne sa zvy\u0161uje o jedna, tak\u017ee sa pos\u00favame na \u010fal\u0161ie prvky. Mus\u00edme si da\u0165 pozor, aby sme zastavili cyklus dostato\u010dne skoro a z\u00e1rove\u0148 nezabudli na \u017eiaden prvok. Index prv\u00e9ho prvku je nula, index druh\u00e9ho jedna, at\u010f. Tak\u017ee ak d\u013a\u017eka zoznamu je 5, posledn\u00fd index je 4. Posledn\u00fd index je v\u017edy o jedna men\u0161\u00ed ne\u017e d\u013a\u017eka zoznamu. Preto sme pou\u017eili v podmienke porovnanie i < len( numbers ) . Ke\u010f po poslednom prvku zv\u00fd\u0161ime i o jedna, u\u017e sa bude rovna\u0165 d\u013a\u017eke zoznamu, a cyklus skon\u010d\u00ed. \u00daloha Vytvorte podobn\u00fd program s nasleduj\u00facimi dvomi rozdielmi: Namiesto priemeru, vypo\u010d\u00edtajte medi\u00e1n : \"Na n\u00e1jdenie medi\u00e1nu dan\u00e9ho s\u00faboru sta\u010d\u00ed hodnoty usporiada\u0165 pod\u013ea ve\u013ekosti a zobra\u0165 hodnotu, ktor\u00e1 sa nach\u00e1dza v strede zoznamu. Ak m\u00e1 s\u00fabor p\u00e1rny po\u010det prvkov, zvy\u010dajne sa za medi\u00e1n ozna\u010d\u00ed aritmetick\u00fd priemer hodn\u00f4t na mieste n/2 a (n+2)/2, ktor\u00e9 sa nach\u00e1dzaj\u00fa v oblasti prostrednej hodnoty.\" U\u017e\u00edvate\u013e najprv zad\u00e1 ko\u013eko \u010d\u00edsel bude nasledova\u0165, potom na ka\u017edom riadku nap\u00ed\u0161e jedno \u010d\u00edslo. Tak\u017ee u\u017e nemus\u00ed ukon\u010di\u0165 \u010d\u00edsla textom \"end\". Pr\u00edklad toho, \u010do m\u00f4\u017ee zada\u0165 pou\u017e\u00edvate\u013e: 4 25 7 1 13 Medi\u00e1n t\u00fdchto \u0161tyroch \u010d\u00edsel je (7 + 13) / 2 = 10. for ... in ... Na iterovanie (prech\u00e1dzanie prvkov) cez zoznam sme pou\u017eili while cyklus. Nie je to jedin\u00e1 mo\u017enos\u0165 a v tejto \u010dasti si uk\u00e1\u017eeme vhodnej\u0161iu riadiacu \u0161trukt\u00faru. >>> for n in [ 1 , 5 , 3 ]: ... print ( 'n =' , n ) ... n = 1 n = 5 n = 3 Na konci pr\u00edkazu for in je dvojbodka, tak\u017ee telo cyklu znovu mus\u00ed by\u0165 odsaden\u00e9 doprava. Tak\u00e9to kr\u00e1tke programy vieme p\u00edsa\u0165 aj priamo v shelli, ... na za\u010diatku znamenaj\u00fa, \u017ee n\u00e1\u0161 program/pr\u00edkaz pokra\u010duje. Za posledn\u00fdmi ... stla\u010d\u00edme hne\u010f Enter, t\u00fdm d\u00e1me najavo, \u017ee sme n\u00e1\u0161 program dop\u00edsali a shell ho spust\u00ed (interpretuje). Medzi slov\u00ed\u010dkami for a in p\u00ed\u0161eme n\u00e1zov premennej. Do tejto premennej bud\u00fa postupne ukladan\u00e9 v\u0161etky hodnoty zo zoznamu uvedenom po in . Tento nov\u00fd typ cyklu vyu\u017eijeme v programe r\u00e1taj\u00facom priemer \u010d\u00edsel. Namiesto while cyklu a pomocnej premennej i , nap\u00ed\u0161eme len: summ = 0 for number in numbers : summ += number Program vieme dokonca zjednodu\u0161i\u0165 e\u0161te viac. Python pozn\u00e1 pr\u00edkaz sum() , ktor\u00fdm s\u010d\u00edta v\u0161etky hodnoty v zozname: summ = sum ( numbers ) Mimochodom, to je d\u00f4vod, pre\u010do sme na n\u00e1zov premennej nepou\u017eili \"sum\" ale \"summ\". Podobne by sme nemali pou\u017e\u00edva\u0165 n\u00e1zvy premenn\u00fdch ako \"for\", \"in\", \"else\", at\u010f. V\u00e4\u010d\u0161inou plat\u00ed, \u017ee ak n\u00e1m editor zafarb\u00ed slovo na nejak\u00fa farbu, tak je to slovo vyhraden\u00e9 pre jazyk Python a ak nechceme ma\u0165 probl\u00e9my, nebudeme ho pou\u017e\u00edva\u0165 na n\u00e1zov premennej. Pozn\u00e1mka Aj na textov\u00fd re\u0165azec sa m\u00f4\u017eme pozera\u0165 ako na zoznam, a to zoznam znakov. >>> for c in 'word' : ... print ( 2 * c ) ... ww oo rr dd \u00daloha Nap\u00ed\u0161te program, ktor\u00fd sa sp\u00fdta u\u017e\u00edvate\u013ea na jedno, \u013eubovo\u013en\u00e9 slovo. Potom vyp\u00ed\u0161e jeho p\u00edsmena spolu s porad\u00edm. Napr.: Enter one word: apple 1. letter: a 2. letter: p 3. letter: p 4. letter: l 5. letter: e","title":"Python: vstup, riadiace \u0161trukt\u00fary, zoznam"},{"location":"02/#python-vstup-riadiace-struktury-zoznam","text":"Dnes si uk\u00e1\u017eeme ako v programe aj \u010d\u00edta\u0165, nielen vypisova\u0165 na obrazovku, uk\u00e1\u017eeme si viac pr\u00edkazov podobn\u00fdch while u a nov\u00fd, zlo\u017eitej\u0161\u00ed, d\u00e1tov\u00fd typ.","title":"Python: vstup, riadiace \u0161trukt\u00fary, zoznam"},{"location":"02/#nacitanie-vstupu","text":"Pripome\u0148me si n\u00e1\u0161 program na kreslenie trojuholn\u00edkov: size = 3 while size > 0 : print ( '*' * size ) size -= 1 Na to, aby sme zmenili ve\u013ekos\u0165, v\u017edy znovu a znovu mus\u00edme prep\u00edsa\u0165 n\u00e1\u0161 zdrojov\u00fd k\u00f3d. Bolo by pekn\u00e9, ke\u010f by sme mali len jeden program, ten spust\u00edme a sp\u00fdta sa n\u00e1s na ve\u013ekos\u0165, ak\u00fa m\u00e1 pou\u017ei\u0165. Tomu sa hovor\u00ed na\u010d\u00edtanie vstupu a sl\u00fa\u017ei na to pr\u00edkaz input . Po\u010fme si ho vysk\u00fa\u0161a\u0165 v pr\u00edkazovom riadku: >>> input () hello 'hello' >>> input ( 'Enter Your name: ' ) Enter Your name : robot 'robot' Po zadan\u00ed pr\u00edkazu input() , shell \u010dak\u00e1, pok\u00fdm zad\u00e1me nejak\u00fd text a stla\u010d\u00edme Enter . Potom vyp\u00ed\u0161e v\u00fdsledok (rovnako ako ke\u010f sme vyu\u017e\u00edvali Python na r\u00e1tanie pr\u00edkladov) -- v\u00fdsledkom pr\u00edkazu input() je v tomto pr\u00edpade text 'hello'. Ke\u010f medzi z\u00e1tvorky vp\u00ed\u0161eme text, pou\u017eije tento text ako prompt. Vyp\u00ed\u0161e ho a znovu \u010dak\u00e1 na n\u00e1s, aby sme mu nie\u010do nap\u00edsali. V\u00fdsledok input() u si m\u00f4\u017eme ulo\u017ei\u0165 do premennej: >>> year = input ( 'Favorite year? ' ) Favorite year ? 1965 >>> year '1965'","title":"Na\u010d\u00edtanie vstupu"},{"location":"02/#vylepsenie-kreslica","text":"Na\u010d\u00edtanie ve\u013ekosti cez input() je jednoduch\u00e9... size = input ( 'Enter size: ' ) while size > 0 : print ( '*' * size ) size -= 1 ...alebo nie? Dok\u00e1\u017eete zisti\u0165 z chybovej hl\u00e1\u0161ky, \u010do sa stalo? Pri porovn\u00e1van\u00ed size > 0 sa Pythonu nep\u00e1\u010di, \u017ee porovn\u00e1vame 'str' a 'int', teda text a \u010d\u00edslo. Tak\u017ee premenn\u00e1 \"size\" m\u00e1 typ 'str'. Pozrime sa na to v shelli: >>> a = input () 1 >>> type ( a ) < class ' str '> Naozaj, v\u00fdsledkom input() u je text. My potrebujeme tento text konvertova\u0165 na \u010d\u00edslo, na pomoc n\u00e1m pr\u00edde \u010fal\u0161\u00ed pr\u00edkaz -- int() : >>> int ( '32' ) 32 >>> int ( '-1' ) - 1 >>> int ( 42 ) 42 >>> int ( '4.2' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : invalid literal for int () with base 10 : '4.2' >>> int ( 'd4' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : invalid literal for int () with base 10 : 'd4' >>> int ( 4.2 ) 4 >>> int ( False ) 0 Tento pr\u00edkaz sa sna\u017e\u00ed hociak\u00fa hodnotu previes\u0165 na cel\u00e9 \u010d\u00edslo. Ke\u010f sa to ned\u00e1, skon\u010d\u00ed s chybou. Desatinn\u00e9 \u010d\u00edslo 4.2 prevedie tak, \u017ee desatinn\u00fa \u010das\u0165 jednoducho zahod\u00ed. Ale text 4.2 nevie konvertova\u0165. Na to by sme najprv museli previes\u0165 text do desatinn\u00e9ho \u010d\u00edsla a potom do cel\u00e9ho: >>> int ( float ( '4.2' ) ) 4 \u00daloha Pre ka\u017ed\u00fd datov\u00fd typ, ktor\u00fd pozn\u00e1me, existuje tak\u00e1to konvertovacia funkcia: int , float , str , bool . Vysk\u00fa\u0161ajte si napr. konvertova\u0165 \u010d\u00edslo na 'bool' alebo previes\u0165 \u010d\u00edslo na text a potom zase sp\u00e4\u0165 na \u010d\u00edslo. N\u00e1\u0161 opraven\u00fd program teda vyzer\u00e1: size = int ( input ( 'Enter size: ' ) ) while size > 0 : print ( '*' * size ) size -= 1 V\u00fdsledok z input() , \u010do je text, vhod\u00edme do pr\u00edkazu int() , a dostaneme v\u00fdsledok ako cel\u00e9 \u010d\u00edslo, ktor\u00e9 u\u017e m\u00f4\u017eme pou\u017ei\u0165 na porovnanie, od\u010d\u00edtanie aj n\u00e1sobenie. Probl\u00e9m je, ak zad\u00e1me text, ktor\u00fd sa ned\u00e1 konvertova\u0165 na \u010d\u00edslo. Tento probl\u00e9m sa d\u00e1 vyrie\u0161i\u0165, my to zatia\u013e nevieme, ale nie je to tak\u00e9 d\u00f4le\u017eit\u00e9. Ak chce niekto pou\u017e\u00edva\u0165 n\u00e1\u0161 program, tak m\u00e1 vedie\u0165, ako p\u00edsa\u0165 \u010d\u00edsla! \u00daloha 1 Nap\u00ed\u0161te program, ktor\u00fd sa sp\u00fdta pou\u017e\u00edvate\u013ea na meno a n\u00e1sledne ho pozdrav\u00ed. Beh programu potom m\u00f4\u017ee vyzera\u0165 napr\u00edklad takto: What's Your name? Kubko Hello Kubko! \u00daloha 2 Vytvorte program, ktor\u00fd si vy\u017eiada rok narodenia a vyp\u00ed\u0161e, ko\u013ekat\u00e9 narodeniny m\u00e1 dan\u00fd \u010dlovek v s\u00fa\u010dasnom roku.","title":"Vylep\u0161enie kresli\u010da"},{"location":"02/#podmieneny-prikaz","text":"Jeden probl\u00e9m s na\u0161im kresli\u010dom trojuholn\u00edkov ale predsa len vyrie\u0161ime. Ke\u010f si teraz niekto pust\u00ed n\u00e1\u0161 program a zad\u00e1 ve\u013ekos\u0165 \"-3\", program ni\u010d nevyp\u00ed\u0161e, len ticho skon\u010d\u00ed (overte si to). Bolo by pekn\u00e9 pou\u017e\u00edvate\u013ea informova\u0165 o tom, \u017ee mus\u00ed zada\u0165 nez\u00e1porn\u00fa ve\u013ekos\u0165. Potrebujeme otestova\u0165, \u010di plat\u00ed size < 0 , na to vyu\u017eijeme podmienen\u00fd pr\u00edkaz if . Pozrime sa na nasleduj\u00faci program (spustite si ho): if 1 < 2 : print ( '1 < 2' ) if 2 < 1 : print ( 'Python is wrong' ) else : print ( 'Python is right' ) Anglick\u00e9 slov\u00ed\u010dko \"if\" znamen\u00e1 \"ak\" a \"else\" znamen\u00e1 \"inak\". Tak\u017ee, ke\u010f si pre\u010d\u00edtame zdrojov\u00fd k\u00f3d, hne\u010f vieme, ako tento nov\u00fd pr\u00edkaz (presnej\u0161ie, riadiaca \u0161trukt\u00fara ) funguje. Ak 1 je menej ne\u017e 2, nap\u00ed\u0161 \"1 < 2\". Ak 2 < 1, nap\u00ed\u0161 \"Python is wrong\", inak nap\u00ed\u0161 \"Python is right\". V\u0161imnime si, \u017ee na konci riadku s if alebo else je v\u017edy dvojbodka. Rovnako sme ju tam p\u00edsali, ke\u010f sme pou\u017e\u00edvali while . Ozna\u010duje, \u017ee nieko\u013eko \u010fal\u0161\u00edch riadkov bude odsaden\u00fdch o \u0161tyri medzeri vpravo a maj\u00fa sa bra\u0165 ako jeden blok k\u00f3du. V\u0161imnime si rozdiel v t\u00fdchto dvoch programoch: if False : print ( 'A' ) print ( 'B' ) if False : print ( 'A' ) print ( 'B' ) Ke\u010f ich spust\u00edme, ka\u017ed\u00fd vykon\u00e1 nie\u010do in\u00e9. Python je ve\u013emi h\u00e1kliv\u00fd na medzery na za\u010diatku riadku. V podstate je jedno, ko\u013eko ich tam bude, ale v\u017edy, ak m\u00e1 by\u0165 nejak\u00fd blok k\u00f3du odsaden\u00fd vpravo (teda v\u017edy za dvojbodkou), nejak\u00e1 medzera tam mus\u00ed by\u0165 a treba tento po\u010det dodr\u017eiava\u0165. Obydva nasleduj\u00face programy skon\u010dia s chybou (sk\u00faste si ich spusti\u0165): if False : print ( 'A' ) if False : print ( 'A' ) print ( 'A' ) Prv\u00fd z nich nem\u00e1 blok odsaden\u00fd v\u00f4bec, druh\u00fd nepou\u017e\u00edva po\u010det medzier konzistentne. Je be\u017en\u00e9 odsadzova\u0165 bloky v\u017edy o 4 medzery, a tak to budeme robi\u0165 aj my.","title":"Podmienen\u00fd pr\u00edkaz"},{"location":"02/#elif","text":"K pr\u00edkazom if , else , e\u0161te existuje tret\u00ed kamar\u00e1t: elif . Znamen\u00e1 nie\u010do ako \"inak, ak ...\". Uk\u00e1\u017eeme si jeho pou\u017eitie, z ktor\u00e9ho to bude najlep\u0161ie vidie\u0165. grade = input () if grade == 'A' : print ( 'Excellent!' ) elif grade == 'B' : print ( 'Good' ) elif grade == 'C' : print ( 'Not bad' ) elif grade == 'D' : print ( 'You could do better' ) else : print ( 'I know only four grades: A, B, C, D' ) Python najprv otestuje, \u010di pou\u017e\u00edvate\u013e zadal p\u00edsmeno \"A\", ak nie, otestuje \"B\", at\u010f., ak nie ani \"D\", vykon\u00e1 posledn\u00fd blok k\u00f3du. \u00daloha Sk\u00faste e\u0161te vylep\u0161i\u0165 kresli\u010da tak, \u017ee ak u\u017e\u00edvate\u013e zad\u00e1 z\u00e1porn\u00e9 \u010d\u00edslo, nap\u00ed\u0161e mu, \u017ee mus\u00ed zada\u0165 kladn\u00e9 (alebo nulu). Ak zad\u00e1 v\u00e4\u010d\u0161ie \u010d\u00edslo ne\u017e 10, vyp\u00ed\u0161e spr\u00e1vu otom, \u017ee je to pr\u00edli\u0161 ve\u013ea a mal by po\u017eiada\u0165 o men\u0161iu ve\u013ekos\u0165. Ak ani jeden z t\u00fdchto scen\u00e1rov sa nestane, tak potom program vykresl\u00ed trojuholn\u00edk. Pou\u017eite na to pr\u00edkazy if , elif a else . Mal\u00e1 rada: odsaden\u00fd m\u00f4\u017ee (dokonca mus\u00ed) by\u0165 aj u\u017e odsaden\u00fd k\u00f3d. Napr\u00edklad nasleduj\u00faci zdrojov\u00fd k\u00f3d je validn\u00fd: if 1 == 1 : if 2 == 2 : print ( '1 == 1 and 2 == 2' )","title":"elif"},{"location":"02/#logicke-operatory","text":"U\u017e pozn\u00e1me logick\u00e9 hodnoty: False a True . Vieme, \u017ee v\u00fdsledkom porovn\u00e1vac\u00edch oper\u00e1torov s\u00fa pr\u00e1ve tieto hodnoty. Ale \u010do ak potrebujeme otestova\u0165 dve podmienky naraz? Napr. \"Ak vonku pr\u0161\u00ed a je pondelok, nep\u00f4jdem do \u0161koly\". M\u00f4\u017eeme tak\u00fd program nap\u00edsa\u0165 pomocou dvoch pr\u00edkazov if : if wheather == 'raining' : if weekday == 'monday' : go_to_school = False Teraz si uk\u00e1\u017eeme 3 logick\u00e9 oper\u00e1tory, ktor\u00e9 n\u00e1m pom\u00f4\u017eu nap\u00edsa\u0165 aj zlo\u017eitej\u0161ie podmienky v jednom if e.","title":"Logick\u00e9 oper\u00e1tory"},{"location":"02/#a-zaroven","text":"if a and b : ... a b V\u00fdsledok True True True True False False False True False False False False","title":"A z\u00e1rove\u0148"},{"location":"02/#alebo","text":"if a or b : ... a b V\u00fdsledok True True True True False True False True True False False False","title":"Alebo"},{"location":"02/#zapor","text":"if not a : ... a V\u00fdsledok True False False True","title":"Z\u00e1por"},{"location":"02/#pouzitie","text":"Nieko\u013eko pr\u00edpadov pou\u017eitia si uk\u00e1\u017eeme v shelli: >>> ( 1 < 2 ) and ( 3 < 4 ) True >>> 'A' == 'B' or 1 != 2 True >>> 1 == 2 or 2 == 1 False >>> not 4 > 5 True >>> False or not 1 >= 1 False Z\u00e1tvorky pou\u017ei\u0165 m\u00f4\u017eeme, ale ke\u010f\u017ee porovn\u00e1vacie oper\u00e1tory maj\u00fa vy\u0161\u0161iu prioritu ako logick\u00e9, vyhodnotia sa e\u0161te pred nimi, a teda to nie je nutn\u00e9.","title":"Pou\u017eitie"},{"location":"02/#neodbytnejsi-kreslic","text":"Uprav\u00edme teraz kresli\u010da trojuholn\u00edkov tak, aby v pr\u00edpade nevalidnej ve\u013ekosti neskon\u010dil hne\u010f, ale bol neodbytn\u00fd a p\u00fdtal sa na ve\u013ekos\u0165, pok\u00fdm nejak\u00fa nedostane (alebo nebude nakoniec v z\u00farivosti vypnut\u00fd pomocou Ctrl + C ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 done = False while not done : size = int ( input ( 'Enter size: ' ) ) if size < 0 or size > 10 : print ( 'Error!' ) if size < 0 : print ( 'We need a non-negative size' ) elif size > 10 : print ( 'This is too much. We accept at most size of 10.' ) else : done = True while size > 0 : print ( '*' * size ) size -= 1 Prejdime si zdrojov\u00fd k\u00f3d riadok za riadkom: 1 done = False V tejto premennej si budeme uchov\u00e1va\u0165 inform\u00e1ciu o tom, \u010di sa n\u00e1m u\u017e podarilo na\u010d\u00edta\u0165 validn\u00fd vstup (ve\u013ekos\u0165). Na za\u010diatku programu rozhodne e\u0161te \u017eiaden vstup od u\u017e\u00edvate\u013ea nem\u00e1me, preto nastav\u00edme done na False . 3 4 while not done : size = int ( input ( 'Enter size: ' ) ) Toto je hlavn\u00fd cyklus na\u010d\u00edtavania ve\u013ekosti. Pok\u00fdm nebudeme ma\u0165 pozna\u010den\u00e9 v done , \u017ee u\u017e sme na\u010d\u00edtali dobr\u00fd vstup, cyklus sa bude opakova\u0165. Sp\u00f4sob na\u010d\u00edtania u\u017e pozn\u00e1me. 6 7 8 9 10 11 12 if size < 0 or size > 10 : print ( 'Error!' ) if size < 0 : print ( 'We need a non-negative size' ) elif size > 10 : print ( 'This is too much. We accept at most size of 10.' ) Otestujeme, \u010di je ve\u013ekos\u0165 validn\u00e1. Ak nie, nap\u00ed\u0161eme pou\u017e\u00edvate\u013eovi, \u017ee nie\u010do je zle a potom aj \u010cO je zle. 13 14 else : done = True Ak je v\u0161etko OK, pozna\u010d\u00edme si, \u017ee sa n\u00e1m podarilo na\u010d\u00edta\u0165 ve\u013ekos\u0165, a tak pri \u010fal\u0161om testovan\u00ed podmienky cyklu, v\u00fdraz not done sa vyhodnot\u00ed na False a program bude pokra\u010dova\u0165 za while cyklom. 16 17 18 while size > 0 : print ( '*' * size ) size -= 1 Tu sa ni\u010d nezmenilo, tak ako aj doteraz, vykresl\u00edme trojuholn\u00edk. \u00daloha Vytvorte program, ktor\u00fd nech\u00e1 pou\u017e\u00edvate\u013ea h\u00e1da\u0165, ak\u00e9 \u010d\u00edslo si mysl\u00ed po\u010d\u00edta\u010d. Vyzera\u0165 by to mohlo podobne ako: Let's play a game: Guess the number I've chosen (1..100 inclusive) Your guess: 12 Try a greater number Your guess: 50 Try a lower number Your guess: 45 Try a lower number Your guess: 42 Congratulation! Pozn\u00e1mka: Vytvori\u0165 v programe n\u00e1hodn\u00e9 \u010d\u00edslo e\u0161te nevieme, zatia\u013e k\u013eudne m\u00f4\u017ee by\u0165 toto \u010d\u00edslo priamo nap\u00edsan\u00e9 v zdrojovom k\u00f3de a ulo\u017een\u00e9 v premennej na za\u010diatku k\u00f3du. number = 42 # Main program logic follows...","title":"Neodbytnej\u0161\u00ed kresli\u010d"},{"location":"02/#zoznam","text":"Zopakujme si, ak\u00e9 d\u00e1tov\u00e9 typy pozn\u00e1me: cel\u00e9 \u010d\u00edsla - 'int' desatinn\u00e9 \u010d\u00edsla - 'float' textov\u00fd re\u0165azec - 'str' logick\u00e1 hodnota - 'bool' Teraz si do tohto zoznamu prid\u00e1me \u010fal\u0161\u00ed: zoznam - 'list' Ako aj n\u00e1zov napoved\u00e1, do zoznamu si budeme uklada\u0165 viacero hodn\u00f4t. Je to vlastne postupnos\u0165 \u010d\u00edsel, textu, logick\u00fdch hodn\u00f4t, ..., dokonca aj samotn\u00fdch zoznamov. Aby sme vytvorili zoznam hodn\u00f4t, vp\u00ed\u0161eme ich medzi hranat\u00e9 z\u00e1tvorky. >>> [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ] >>> [ 1 , False , 3 , 'ABCD' , 5 , [ 4.2 , [] ] ] [ 1 , False , 3 , 'ABCD' , 5 , [ 4.2 , []]] >>> type ( [ 1 , False , 'ABC' ] ) < class ' list '> Hodnoty ulo\u017een\u00e9 v zozname naz\u00fdvame prvky a pristupujeme k nim cez index . Index je poradie prvku od za\u010diatku zoznamu, pri\u010dom prv\u00fd prvok m\u00e1 index 0. Na indexovanie pou\u017e\u00edvame hranat\u00e9 z\u00e1tvorky. >>> l = [ 1 , False , 3 , 'ABCD' , 5 , [ 4.2 , [] ] ] >>> l [ 0 ] 1 >>> l [ 1 ] False >>> l [ 5 ] [ 4.2 , []] >>> l [ 5 ][ 1 ] [] >>> l [ - 1 ] [ 4.2 , []] >>> l [ - 2 ] 5 >>> l [ 6 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > IndexError : list index out of range Indexy m\u00f4\u017eu by\u0165 aj z\u00e1porn\u00e9, vtedy ozna\u010duje poradie odzadu. No pozor na pr\u00edli\u0161 vysok\u00e9 indexy. Ak chceme prist\u00fapi\u0165 k prvku za koncom zoznamu, dostaneme chybov\u00fa hl\u00e1\u0161ku. Prvky v zozname m\u00f4\u017eeme aj upravova\u0165: >>> l [ 1 ] = 2 >>> l [ 1 , 2 , 3 , 'ABCD' , 5 , [ 4.2 , []]] A pr\u00edpadne cel\u00fd zoznam vieme pred\u013a\u017ei\u0165. Existuje viacero sp\u00f4sobov: >>> l = [ 1 , 2 ] >>> l . append ( 3 ) >>> l [ 1 , 2 , 3 ] >>> l . extend ( [ 4 , 5 , 5 ] ) >>> l [ 1 , 2 , 3 , 4 , 5 , 5 ] >>> l + [ 0 ] [ 1 , 2 , 3 , 4 , 5 , 5 , 0 ] >>> l [ 1 , 2 , 3 , 4 , 5 , 5 ] >>> l += [ 0 ] >>> l [ 1 , 2 , 3 , 4 , 5 , 5 , 0 ] Oper\u00e1tor + vytvor\u00ed nov\u00fd zoznam z p\u00f4vodn\u00fdch dvoch -- tieto dva zostan\u00fa nezmenen\u00e9. Ak chceme zoznam pred\u013a\u017ei\u0165, a teda naozaj ho zmeni\u0165, mus\u00edme na to pou\u017ei\u0165 oper\u00e1tor += . A vieme ho zase skr\u00e1ti\u0165: >>> l . pop () 0 >>> l [ 1 , 2 , 3 , 4 , 5 , 5 ] >>> a = l . pop () >>> a 5 >>> l [ 1 , 2 , 3 , 4 , 5 ] >>> del l [ 1 ] >>> l [ 1 , 3 , 4 , 5 ] pop() zma\u017ee posledn\u00fd prvok, ktor\u00fd si z\u00e1rove\u0148 m\u00f4\u017eeme niekam ulo\u017ei\u0165. del vyma\u017ee \u013eubovo\u013en\u00fd prvok na danom indexe. Uk\u00e1\u017eme si, \u010do e\u0161te vieme so zoznamom robi\u0165: >>> l . reverse () # obr\u00e1ti zoznam >>> l [ 5 , 4 , 3 , 1 ] >>> l . clear () # vyma\u017ee v\u0161etky prvky >>> l [] >>> l = [ 1 ] >>> l . insert ( 0 , 8 ) # vlo\u017e\u00ed prvok 8 na index 0 >>> l [ 8 , 1 ] >>> l . insert ( 1 , 9 ) >>> l [ 8 , 9 , 1 ] >>> l . remove ( 8 ) # odstr\u00e1ni prv\u00fd v\u00fdskit prvku 8 >>> l [ 9 , 1 ] >>> l . remove ( 0 ) # ak dan\u00fd prvok neexistuje, chyba Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : list . remove ( x ): x not in list >>> l = [ 1 , 4 , 4 , 9 , 2 , 0 , 3 , 4 ] >>> l . count ( 1 ) # spo\u010d\u00edta po\u010det v\u00fdskitov prvku 1 >>> l . count ( 4 ) 3 >>> l . count ( 42 ) 0 >>> l . sort () # zorad\u00ed zoznam >>> l [ 0 , 1 , 2 , 3 , 4 , 4 , 4 , 9 ] >>> l . index ( 4 ) # vr\u00e1ti index prv\u00e9ho v\u00fdskitu prvku 4 >>> l . index ( 5 ) # chyba, podobne ako pri 'remove' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : 5 is not in list >>> len ( l ) # zist\u00ed d\u013a\u017eku (po\u010det prvkov) zoznamu 8 >>> len ( [ 'robo' , 'lab' ] ) 2 >>> len ( [] ) 0 >>> 3 in [ 2 , 3 , 1 ] # test na pr\u00edtomnos\u0165 prvku v zozname True >>> 1 in [ 4 , 5 ] False >>> 'l' in 'hello' True >>> 0 in [] False","title":"Zoznam"},{"location":"02/#priemer-cisel","text":"Aby sme si uk\u00e1zali pr\u00edklad vyu\u017eitia zoznamu, vytvor\u00edme program, ktor\u00fd vypo\u010d\u00edta priemer \u010d\u00edsel zadan\u00fdch pou\u017e\u00edvate\u013eom. Tie si budeme uklada\u0165 do zoznamu. Ako budeme ale vedie\u0165, kedy u\u017e\u00edvate\u013e u\u017e nap\u00edsal v\u0161etky \u010d\u00edsla? D\u00e1me mu mo\u017enos\u0165 to ozn\u00e1mi\u0165 napr. t\u00fdm, \u017ee zad\u00e1 text \"end\". 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 print ( 'I \\' ll compute the mean value of all the entered numbers.' ) print ( 'Type \"end\" after entering all of them.' ) done = False numbers = [] while not done : number = input ( 'Enter a number (or \"end\"): ' ) if number == 'end' : done = True else : numbers . append ( int ( number ) ) print ( 'Entered numbers:' , numbers ) Na za\u010diatku u\u017e\u00edvate\u013ea informujeme o tom ako pou\u017e\u00edva\u0165 n\u00e1\u0161 program. V\u0161imnime si, \u017ee na to, aby sme vyp\u00edsali jednoduch\u00fa \u00favodzovku, mus\u00edme pred \u0148u nap\u00edsa\u0165 \u0161peci\u00e1lny znak sp\u00e4tn\u00e9 lom\u00edtko (\\). Je to preto, lebo \u00favodzovkami sa ozna\u010duje za\u010diatok a koniec textov\u00e9ho re\u0165azca. Ak by sme nepou\u017eili sp\u00e4tn\u00e9 lom\u00edtko, Python by ako text pochopil iba \"I\" a dostali by sme chybu. Vstup na\u010d\u00edtame najprv ako text, aby sme mohli otestova\u0165 koniec zad\u00e1vania \u010d\u00edsel, a ke\u010f ten nenastane, konvertujeme ho na cel\u00e9 \u010d\u00edslo a prid\u00e1me do zoznamu. Na konci vyp\u00ed\u0161eme v\u0161etky \u010d\u00edsla z ktor\u00fdch budeme r\u00e1ta\u0165 priemer. 1 2 3 4 5 6 7 8 i = 0 summ = 0 while i < len ( numbers ): summ += numbers [ i ] i += 1 print ( 'Mean:' , summ / len ( numbers ) ) Aby sme vypo\u010d\u00edtali priemer, najprv pomocou cyklu s\u010d\u00edtame v\u0161etky \u010d\u00edsla. Premenn\u00e1 i m\u00e1 na za\u010diatku hodnotu nula, teda index prv\u00e9ho prvu. Postupne sa zvy\u0161uje o jedna, tak\u017ee sa pos\u00favame na \u010fal\u0161ie prvky. Mus\u00edme si da\u0165 pozor, aby sme zastavili cyklus dostato\u010dne skoro a z\u00e1rove\u0148 nezabudli na \u017eiaden prvok. Index prv\u00e9ho prvku je nula, index druh\u00e9ho jedna, at\u010f. Tak\u017ee ak d\u013a\u017eka zoznamu je 5, posledn\u00fd index je 4. Posledn\u00fd index je v\u017edy o jedna men\u0161\u00ed ne\u017e d\u013a\u017eka zoznamu. Preto sme pou\u017eili v podmienke porovnanie i < len( numbers ) . Ke\u010f po poslednom prvku zv\u00fd\u0161ime i o jedna, u\u017e sa bude rovna\u0165 d\u013a\u017eke zoznamu, a cyklus skon\u010d\u00ed. \u00daloha Vytvorte podobn\u00fd program s nasleduj\u00facimi dvomi rozdielmi: Namiesto priemeru, vypo\u010d\u00edtajte medi\u00e1n : \"Na n\u00e1jdenie medi\u00e1nu dan\u00e9ho s\u00faboru sta\u010d\u00ed hodnoty usporiada\u0165 pod\u013ea ve\u013ekosti a zobra\u0165 hodnotu, ktor\u00e1 sa nach\u00e1dza v strede zoznamu. Ak m\u00e1 s\u00fabor p\u00e1rny po\u010det prvkov, zvy\u010dajne sa za medi\u00e1n ozna\u010d\u00ed aritmetick\u00fd priemer hodn\u00f4t na mieste n/2 a (n+2)/2, ktor\u00e9 sa nach\u00e1dzaj\u00fa v oblasti prostrednej hodnoty.\" U\u017e\u00edvate\u013e najprv zad\u00e1 ko\u013eko \u010d\u00edsel bude nasledova\u0165, potom na ka\u017edom riadku nap\u00ed\u0161e jedno \u010d\u00edslo. Tak\u017ee u\u017e nemus\u00ed ukon\u010di\u0165 \u010d\u00edsla textom \"end\". Pr\u00edklad toho, \u010do m\u00f4\u017ee zada\u0165 pou\u017e\u00edvate\u013e: 4 25 7 1 13 Medi\u00e1n t\u00fdchto \u0161tyroch \u010d\u00edsel je (7 + 13) / 2 = 10.","title":"Priemer \u010d\u00edsel"},{"location":"02/#for-in","text":"Na iterovanie (prech\u00e1dzanie prvkov) cez zoznam sme pou\u017eili while cyklus. Nie je to jedin\u00e1 mo\u017enos\u0165 a v tejto \u010dasti si uk\u00e1\u017eeme vhodnej\u0161iu riadiacu \u0161trukt\u00faru. >>> for n in [ 1 , 5 , 3 ]: ... print ( 'n =' , n ) ... n = 1 n = 5 n = 3 Na konci pr\u00edkazu for in je dvojbodka, tak\u017ee telo cyklu znovu mus\u00ed by\u0165 odsaden\u00e9 doprava. Tak\u00e9to kr\u00e1tke programy vieme p\u00edsa\u0165 aj priamo v shelli, ... na za\u010diatku znamenaj\u00fa, \u017ee n\u00e1\u0161 program/pr\u00edkaz pokra\u010duje. Za posledn\u00fdmi ... stla\u010d\u00edme hne\u010f Enter, t\u00fdm d\u00e1me najavo, \u017ee sme n\u00e1\u0161 program dop\u00edsali a shell ho spust\u00ed (interpretuje). Medzi slov\u00ed\u010dkami for a in p\u00ed\u0161eme n\u00e1zov premennej. Do tejto premennej bud\u00fa postupne ukladan\u00e9 v\u0161etky hodnoty zo zoznamu uvedenom po in . Tento nov\u00fd typ cyklu vyu\u017eijeme v programe r\u00e1taj\u00facom priemer \u010d\u00edsel. Namiesto while cyklu a pomocnej premennej i , nap\u00ed\u0161eme len: summ = 0 for number in numbers : summ += number Program vieme dokonca zjednodu\u0161i\u0165 e\u0161te viac. Python pozn\u00e1 pr\u00edkaz sum() , ktor\u00fdm s\u010d\u00edta v\u0161etky hodnoty v zozname: summ = sum ( numbers ) Mimochodom, to je d\u00f4vod, pre\u010do sme na n\u00e1zov premennej nepou\u017eili \"sum\" ale \"summ\". Podobne by sme nemali pou\u017e\u00edva\u0165 n\u00e1zvy premenn\u00fdch ako \"for\", \"in\", \"else\", at\u010f. V\u00e4\u010d\u0161inou plat\u00ed, \u017ee ak n\u00e1m editor zafarb\u00ed slovo na nejak\u00fa farbu, tak je to slovo vyhraden\u00e9 pre jazyk Python a ak nechceme ma\u0165 probl\u00e9my, nebudeme ho pou\u017e\u00edva\u0165 na n\u00e1zov premennej. Pozn\u00e1mka Aj na textov\u00fd re\u0165azec sa m\u00f4\u017eme pozera\u0165 ako na zoznam, a to zoznam znakov. >>> for c in 'word' : ... print ( 2 * c ) ... ww oo rr dd \u00daloha Nap\u00ed\u0161te program, ktor\u00fd sa sp\u00fdta u\u017e\u00edvate\u013ea na jedno, \u013eubovo\u013en\u00e9 slovo. Potom vyp\u00ed\u0161e jeho p\u00edsmena spolu s porad\u00edm. Napr.: Enter one word: apple 1. letter: a 2. letter: p 3. letter: p 4. letter: l 5. letter: e","title":"for ... in ..."},{"location":"03/","text":"Python: funkcie, range, vlastn\u00e1 hra Funkcie Pr\u00edkazy print , int , input , len , ..., ktor\u00e9 sme pou\u017e\u00edvali doteraz, maj\u00fa nie\u010do spolo\u010dn\u00e9. Pozrime sa na ne ako na stroje. Do stroja nie\u010do vhod\u00edme, spust\u00edme ho, on nie\u010do sprav\u00ed, a nakoniec nie\u010do vyhod\u00ed zo seba von. Do pr\u00edkazu int vhod\u00edme hodnotu, napr. '10' , prevedie ju na \u010d\u00edslo a vr\u00e1t\u00ed n\u00e1m hodnotu 10 . Tak\u00fdmto pr\u00edkazom hovor\u00edme funkcie . Funkcie maj\u00fa vstup a v\u00fdstup , nie\u010do ber\u00fa ako argument na vstupe a vr\u00e1tia hodnotu na v\u00fdstupe ( n\u00e1vratov\u00e1 hodnota ). Niektor\u00e9 funkcie nemusia ma\u0165 argument, napr. input() , naopak print( 'a', 4, 10 ) m\u00e1 viac argumentov (jednotliv\u00e9 argumenty odde\u013eujeme \u010diarkou), ale zase \u017eiadnu n\u00e1vratov\u00fa hodnotu. Pozn\u00e1mka To, \u017ee print nem\u00e1 n\u00e1vratov\u00fa hodnotu nie je tak \u00faplne pravda: >>> r = print ( 'test' ) test >>> r >>> print ( r ) None >>> type ( r ) < class ' NoneType '> N\u00e1vratov\u00e1 hodnota je None . Je to jedin\u00e1 mo\u017en\u00e1 hodnota d\u00e1tov\u00e9ho typu NoneType . Len pre zauj\u00edmavos\u0165, pre n\u00e1s to teraz v\u00f4bec nie je d\u00f4le\u017eit\u00e9. Dobr\u00e1 spr\u00e1va je: Python umo\u017e\u0148uje vytvori\u0165 si vlastn\u00e9 funkcie! Sl\u00fa\u017ei na to pr\u00edkaz def , znovu na konci obsahuje dvojbodku a nasleduje blok k\u00f3du ( telo funckie ) odsaden\u00fd vpravo, ktor\u00fd sa vykon\u00e1, ak t\u00fato funkciu zavol\u00e1me (to znamen\u00e1, pou\u017eijeme ju v programe). def say_hi ( who ): print ( 'Hi' , who ) say_hi ( 'robot' ) say_hi ( 'Adam' ) Prv\u00fd riadok sa naz\u00fdva hlavi\u010dka funkcie . Ur\u010duje n\u00e1zov funkcie a parametry . Medzi parametrom a argumentom je ve\u013emi slab\u00fd rozdiel a \u010dasto sa ich v\u00fdznam zamie\u0148a. Ak chceme by\u0165 presn\u00fd, 'robot' a 'Adam' s\u00fa argumenty. who je parameter. Ako a uto zaparkuje na p arkovisko, tak aj a rgument zaparkuje na p arameter, tak\u017ee hodnota 'robot' (argument) sa ulo\u017e\u00ed do premennej who (parameter). E\u0161te inak: ak sa pozer\u00e1me zvn\u00fatra funkcie, vid\u00edme parametre. Ak sa pozer\u00e1me zvonka, vid\u00edme argumenty. \u00daloha 1 Nap\u00ed\u0161te funkciu print_max , ktor\u00e1 vyp\u00ed\u0161e maxim\u00e1lny prvok v zozname. Ak je zoznam pr\u00e1zdny, vyp\u00ed\u0161e t\u00fato inform\u00e1ciu. Napr: print_max( [ 3, 9, 0 ] ) vyp\u00ed\u0161e: 9 print_max( [] ) vyp\u00ed\u0161e: Max element does not exist (the list is empty) print_max( 'dkrn' ) vyp\u00ed\u0161e: r \u00daloha 2 Pok\u00faste sa v defin\u00edcii funkcie \"print_max\" pou\u017ei\u0165 funkciu max (ktor\u00e1 je u\u017e vstavan\u00e1 v Pythone). Kr\u00e1tka uk\u00e1\u017eka ako funguje: >>> max ( [ 1 , 2 , 0 ] ) 2 >>> max ( 'dkrn' ) 'r' >>> max ( [] ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : max () arg is an empty sequence Tak\u017ee pozor na to, aby argumentom nebol pr\u00e1zdny zoznam, toto bude treba otestova\u0165 e\u0161te pred t\u00fdm, ako sa zavol\u00e1 funkcia max . \u010co ak by sme chceli aj my nie\u010do vr\u00e1ti\u0165 z na\u0161ej vlastnej funkcie, nielen vypisova\u0165? Sl\u00fa\u017ei na to slov\u00ed\u010dko return : def area ( a , b ): return a * b print ( area ( 2 , 3 ) ) print ( area ( 0 , 10 ) + area ( 10 , 0 ) ) print ( area ( 1 , area ( 2 , 3 ) ) ) # well, this is \"volume\" Prv\u00fd riadok (po defin\u00edcii funkcie area ) zavol\u00e1 area( 2, 3 ) . Do premennej a sa ulo\u017e\u00ed hodnota 2 , do b hodnota 3 . Potom sa vyhodnot\u00ed a * b na hodnotu 12 , ktor\u00e1 sa vr\u00e1ti spa\u0165 a vykon\u00e1 sa print( 12 ) . Podobne si vieme rozobra\u0165 aj posledn\u00fd riadok: print ( area ( 1 , area ( 2 , 3 ) ) ) print ( area ( 1 , 6 ) ) print ( 6 ) Na obrazovke uvid\u00edme text \"6\" \u00daloha Nap\u00ed\u0161te funkciu, ktor\u00e1 vr\u00e1ti po\u010det kladn\u00fdch \u010d\u00edsel v zozname. [] -> 0 [ 2, 3 ] -> 2 [ 0, 4, 9, -2, 10 ] -> 3 [ -2, 0, -5 ] -> 0 range Uk\u00e1\u017eeme si jednu nov\u00fa, u\u017eito\u010dn\u00fa funkciu, hlavne v spojen\u00ed s for ... in cyklom. Vol\u00e1 sa range a m\u00f4\u017ee bra\u0165 jeden, dva, alebo aj tri argumenty. Vr\u00e1ti \u0161peci\u00e1lnu hodnotu typu 'range', ktor\u00fa ale vieme konvertova\u0165 do zoznamu pomocou funkcie list : >>> list ( range ( 10 ) ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 0 ) ) [] >>> list ( range ( 1 ) ) [ 0 ] >>> list ( range ( 0 , 10 ) ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 0 , 0 ) ) [] >>> list ( range ( 3 , 5 ) ) [ 3 , 4 ] >>> list ( range ( - 3 , 3 ) ) [ - 3 , - 2 , - 1 , 0 , 1 , 2 ] >>> list ( range ( - 3 , 3 , 2 ) ) [ - 3 , - 1 , 1 ] >>> list ( range ( 0 , 10 , 1 ) ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 0 , 10 , 3 ) ) [ 0 , 3 , 6 , 9 ] >>> list ( range ( 10 , 0 , - 3 ) ) [ 10 , 7 , 4 , 1 ] range(a, b, c) vygeneruje \u010d\u00edsla od a (vr\u00e1tane) do b (vyn\u00edmaj\u00fac) s rozdielmi c medzi ka\u017ed\u00fdmi dvomi \u010d\u00edslami. Ak pou\u017eijeme iba dva argumenty, c sa nastav\u00ed automaticky na jednotku. A ak iba jeden, a sa nastav\u00ed na nulu. Ak ale pou\u017eijeme t\u00fato funkciu s kon\u0161trukciou for ... in , m\u00f4\u017eme vynecha\u0165 konvertovanie cez list , lebo vie pracova\u0165 aj s \u0161peci\u00e1lnou hodnotou typu 'range', ak\u00fa vracia funkcia range . >>> type ( range ( 5 ) ) < class ' range '> >>> for i in range ( 5 ): ... print ( i ) ... 0 1 2 3 4 for spolu s range \u010dastokr\u00e1t dok\u00e1\u017ee nahradi\u0165 cyklus while a lep\u0161ie sa s n\u00edm pracuje. Ak si spomenieme napr. na n\u00e1\u0161 program kresliaci trojuholn\u00edky, teraz by sme samotn\u00e9 kreslenie (na\u010d\u00edtanie ve\u013ekosti na vstupe zost\u00e1va rovnako) vedeli nap\u00edsa\u0165 nasledovne: for row_size in range ( size , 0 , - 1 ): print ( row_size * '*' ) A nakresli\u0165 opa\u010dn\u00fd trojuholn\u00edk (so \u0161pi\u010dkou na vrchu) by bolo podobne jednoduch\u00e9: for row_size in range ( 1 , size + 1 ): print ( row_size * '*' ) \u00daloha Nap\u00ed\u0161te program, ktor\u00fd sa sp\u00fdta u\u017e\u00edvate\u013ea na dve \u010d\u00edsla. Tie bud\u00fa znamena\u0165 ve\u013ekos\u0165 str\u00e1n obd\u013a\u017enika. Potom pomocou for ... in range vykreslite tak\u00fdto obd\u013a\u017enik. Pre ve\u013ekosti 4 a 6 by mal vyzera\u0165 takto: ###### # # # # ###### Labyrint Po\u010fme si spolu naprogramova\u0165 jednoduch\u00fa hru. U\u017e m\u00e1me nejak\u00e9 skusenosti s programovan\u00edm, tak\u017ee pok\u00fdm sa trochu obmedz\u00edme v na\u0161ich n\u00e1rokoch na kvalitu, zvl\u00e1dneme to \u013eavou zadnou. Cie\u013eom hry bude dosta\u0165 sa v labyrinte do cie\u013ea. Labyrint budeme kresli\u0165 podobne ako v poslednej \u00falohe, mrie\u017eky (#) bud\u00fa ozna\u010dova\u0165 steny, medzery ( ) vo\u013en\u00e9 pol\u00ed\u010dka. Cie\u013e ozna\u010d\u00edme ako p\u00edsmeno X a na\u0161u postavi\u010dku O. V ka\u017edom kole vyzveme pou\u017e\u00edvate\u013ea aby zadal jedno z p\u00edsmenok: w - krok hore a - krok v\u013eavo s - krok dole d - krok vpravo q - ukon\u010di\u0165 hru Na za\u010diatku si zadefinujeme v\u0161etky tieto kon\u0161tanty , teda premenn\u00e9, ktor\u00e9 sa nebud\u00fa meni\u0165. V Pythone je zvykom p\u00edsa\u0165 ich n\u00e1zvy ve\u013ek\u00fdmi p\u00edsmenami. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 FIELD = [ '#############' , '# # ### #X#' , '# # # #' , '# ## ## # # #' , '# # # #' , '##### # # #' , '# # #######' , '# # #' , '#############' ] HEIGHT = len ( FIELD ) WIDTH = len ( FIELD [ 0 ] ) END = 'X' PLAYER = 'O' WALL = '#' UP = 'w' LEFT = 'a' DOWN = 's' RIGHT = 'd' QUIT = 'q' Hracie pole si uklad\u00e1me ako zoznam textov\u00fdch re\u0165azcov - riadkov. V\u00fd\u0161ka po\u013ea je po\u010det riadkov, ktor\u00fd vieme zisti\u0165 funkciou len . Tie\u017e ju pou\u017eijeme na zistenie \u0161\u00edrky, t.j. po\u010det st\u013apcov, ktor\u00fd sa rovn\u00e1 d\u013a\u017eke ka\u017ed\u00e9ho (a teda napr. prv\u00e9ho) riadku. Na za\u010diatku hr\u00e1\u010da umiestnime do \u013eav\u00e9ho doln\u00e9ho rohu. Pam\u00e4tajme, \u017ee indexy za\u010d\u00ednaj\u00fa nulou. X-ov\u00e1 s\u00faradnica je horizont\u00e1lna (z\u013eava doprava), y-ov\u00e1 je vertik\u00e1lna (zhora dolu). 25 26 INITIAL_X = 1 INITIAL_Y = 7 Teraz si nap\u00ed\u0161eme funkciu, ktor\u00e1 vykresl\u00ed hracie pole aj s hr\u00e1\u010dom. Funkcia bude ma\u0165 dva parametre: aktu\u00e1lne s\u00faradnice hr\u00e1\u010da. Budeme prech\u00e1dza\u0165 pomocou vnoren\u00e9ho for cyklu cel\u00e9 hracie pole po riadkoch, ak na danom pol\u00ed\u010dku stoj\u00ed hr\u00e1\u010d, vykresl\u00edme jeho znak, inak vykresl\u00edme pol\u00ed\u010dko z hracieho pola. Doteraz sme print pou\u017e\u00edvali tak, \u017ee na konci v\u00fdstupu v\u017edy vlo\u017eil znak konca riadku (akoby stla\u010dil na konci riadku Enter ). To je jeho prednastaven\u00e9 spr\u00e1vanie. Teraz ale nechceme aby bolo ka\u017ed\u00e9 pol\u00ed\u010dko na svojom vlastnom riadku, chceme ich vykresli\u0165 hne\u010f ved\u013ea seba. Preto pou\u017eijeme \u0161peci\u00e1lny ( optional ) parameter end , kde mu nastav\u00edme znak, ktor\u00fd m\u00e1 vykresli\u0165 na konci v\u00fdstupu. Sk\u00faste si v shelli spusti\u0165 napr. print ( 'afad' , end = '###' ) . My naozaj nechceme vyp\u00edsa\u0165 medzi pol\u00ed\u010dkami ni\u010d, preto nastav\u00edme tento parameter na pr\u00e1zdny text. 28 29 30 31 32 33 34 35 def print_field ( player_x , player_y ): for y in range ( HEIGHT ): for x in range ( WIDTH ): if y == player_y and x == player_x : print ( PLAYER , end = '' ) else : print ( FIELD [ y ][ x ], end = '' ) print () Nap\u00ed\u0161eme si e\u0161te jednu d\u00f4le\u017eit\u00fa funkciu. Bude na\u010d\u00edtava\u0165 vstup od u\u017e\u00edvate\u013ea a pos\u00fava\u0165 hr\u00e1\u010da. Ako vstup zoberie tie\u017e s\u00faradnice hr\u00e1\u010da a vr\u00e1ti 3 hodnoty: nov\u00e9 s\u00faradnice po posune a logick\u00fa hodnotu, \u010di sa m\u00e1 hra ukon\u010di\u0165. Viac ako jednu hodnotu sme doteraz nevr\u00e1tili v \u017eiadnej funkcii, ale je to jednoduch\u00e9: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def is_valid_command ( command ): return command in 'wasdq' def is_empty ( x , y ): return not FIELD [ y ][ x ] == WALL def move ( player_x , player_y ): new_player_x = player_x new_player_y = player_y while True : command = input ( 'Move \"w\", \"a\", \"s\", \"d\" or end \"q\": ' ) if not is_valid_command ( command ): print ( 'Invalid command' ) else : if command == 'w' : new_player_y -= 1 elif command == 'a' : new_player_x -= 1 elif command == 's' : new_player_y += 1 elif command == 'd' : new_player_x += 1 else : # quit return player_x , player_y , True if is_empty ( new_player_x , new_player_y ): return new_player_x , new_player_y , False else : print ( 'You cannot move there' ) new_player_x = player_x new_player_y = player_y Teraz implementujeme hlavn\u00fa logiku. Na\u010d\u00edta\u0165 viacero hodn\u00f4t z funkcie je rovnako jednoduch\u00e9. 70 71 72 73 74 75 76 77 78 79 80 81 82 x = INITIAL_X y = INITIAL_Y end = False while not end : print_field ( x , y ) x , y , end = move ( x , y ) if not end and FIELD [ y ][ x ] == END : print ( 'Congratulation!' ) end = True print ( 'The game ends' ) Tak, a hra je hotov\u00e1 :) Nezabudnite, \u017ee pr\u00edkaz input v\u017edy \u010dak\u00e1 na stla\u010denie kl\u00e1vesy Enter , tak\u017ee sa hra ned\u00e1 ovl\u00e1da\u0165 plynule ako sme zvyknut\u00ed, len dr\u017ean\u00edm \"w\" \"a\" \"s\" \"d\". To by sme mohli e\u0161te vylep\u0161i\u0165, no najbli\u017e\u0161ie si u\u017e postav\u00edme svojho prv\u00e9ho robota a rozpohybujeme ho Pythonom! Z\u00e1rove\u0148 si postupne budeme ukazova\u0165 v\u0161eliak\u00e9 nov\u00e9 u\u017eito\u010dn\u00e9 pr\u00edkazy. \u00daloha Ak e\u0161te m\u00e1te chu\u0165 trochu popracova\u0165 na na\u0161ej hre, tu je nieko\u013eko n\u00e1vrhov: Vytvorte viacero r\u00f4znych blud\u00edsk, nechajte hr\u00e1\u010da, aby si z nich vybral. Pridajte po\u010d\u00edtadlo krokov. \u010c\u00edm viac krokov hr\u00e1\u010d sprav\u00ed pok\u00fdm sa dostane do cie\u013ea, t\u00fdm ni\u017e\u0161ie bude jeho sk\u00f3re, ktor\u00e9 na konci hra vyp\u00ed\u0161e. Do bludiska pridajte diamanty (napr. znak bodky \".\"), tie bude hr\u00e1\u010d zbiera\u0165, tak\u017ee po prejden\u00ed pol\u00ed\u010dka s diamantom, diamant na \u0148om u\u017e nesmie zosta\u0165! Pozbieran\u00e9 diamanty hr\u00e1\u010dovi zvy\u0161uj\u00fa sk\u00f3re. Do hry m\u00f4\u017eete prida\u0165 dvere \"D\" a k\u013e\u00fa\u010d \"K\". Ke\u010f hr\u00e1\u010d zoberie k\u013e\u00fa\u010d, dvere sa mu otvoria a bude m\u00f4c\u0165 prejs\u0165 do cie\u013ea.","title":"Python: funkcie, range, vlastn\u00e1 hra"},{"location":"03/#python-funkcie-range-vlastna-hra","text":"","title":"Python: funkcie, range, vlastn\u00e1 hra"},{"location":"03/#funkcie","text":"Pr\u00edkazy print , int , input , len , ..., ktor\u00e9 sme pou\u017e\u00edvali doteraz, maj\u00fa nie\u010do spolo\u010dn\u00e9. Pozrime sa na ne ako na stroje. Do stroja nie\u010do vhod\u00edme, spust\u00edme ho, on nie\u010do sprav\u00ed, a nakoniec nie\u010do vyhod\u00ed zo seba von. Do pr\u00edkazu int vhod\u00edme hodnotu, napr. '10' , prevedie ju na \u010d\u00edslo a vr\u00e1t\u00ed n\u00e1m hodnotu 10 . Tak\u00fdmto pr\u00edkazom hovor\u00edme funkcie . Funkcie maj\u00fa vstup a v\u00fdstup , nie\u010do ber\u00fa ako argument na vstupe a vr\u00e1tia hodnotu na v\u00fdstupe ( n\u00e1vratov\u00e1 hodnota ). Niektor\u00e9 funkcie nemusia ma\u0165 argument, napr. input() , naopak print( 'a', 4, 10 ) m\u00e1 viac argumentov (jednotliv\u00e9 argumenty odde\u013eujeme \u010diarkou), ale zase \u017eiadnu n\u00e1vratov\u00fa hodnotu. Pozn\u00e1mka To, \u017ee print nem\u00e1 n\u00e1vratov\u00fa hodnotu nie je tak \u00faplne pravda: >>> r = print ( 'test' ) test >>> r >>> print ( r ) None >>> type ( r ) < class ' NoneType '> N\u00e1vratov\u00e1 hodnota je None . Je to jedin\u00e1 mo\u017en\u00e1 hodnota d\u00e1tov\u00e9ho typu NoneType . Len pre zauj\u00edmavos\u0165, pre n\u00e1s to teraz v\u00f4bec nie je d\u00f4le\u017eit\u00e9. Dobr\u00e1 spr\u00e1va je: Python umo\u017e\u0148uje vytvori\u0165 si vlastn\u00e9 funkcie! Sl\u00fa\u017ei na to pr\u00edkaz def , znovu na konci obsahuje dvojbodku a nasleduje blok k\u00f3du ( telo funckie ) odsaden\u00fd vpravo, ktor\u00fd sa vykon\u00e1, ak t\u00fato funkciu zavol\u00e1me (to znamen\u00e1, pou\u017eijeme ju v programe). def say_hi ( who ): print ( 'Hi' , who ) say_hi ( 'robot' ) say_hi ( 'Adam' ) Prv\u00fd riadok sa naz\u00fdva hlavi\u010dka funkcie . Ur\u010duje n\u00e1zov funkcie a parametry . Medzi parametrom a argumentom je ve\u013emi slab\u00fd rozdiel a \u010dasto sa ich v\u00fdznam zamie\u0148a. Ak chceme by\u0165 presn\u00fd, 'robot' a 'Adam' s\u00fa argumenty. who je parameter. Ako a uto zaparkuje na p arkovisko, tak aj a rgument zaparkuje na p arameter, tak\u017ee hodnota 'robot' (argument) sa ulo\u017e\u00ed do premennej who (parameter). E\u0161te inak: ak sa pozer\u00e1me zvn\u00fatra funkcie, vid\u00edme parametre. Ak sa pozer\u00e1me zvonka, vid\u00edme argumenty. \u00daloha 1 Nap\u00ed\u0161te funkciu print_max , ktor\u00e1 vyp\u00ed\u0161e maxim\u00e1lny prvok v zozname. Ak je zoznam pr\u00e1zdny, vyp\u00ed\u0161e t\u00fato inform\u00e1ciu. Napr: print_max( [ 3, 9, 0 ] ) vyp\u00ed\u0161e: 9 print_max( [] ) vyp\u00ed\u0161e: Max element does not exist (the list is empty) print_max( 'dkrn' ) vyp\u00ed\u0161e: r \u00daloha 2 Pok\u00faste sa v defin\u00edcii funkcie \"print_max\" pou\u017ei\u0165 funkciu max (ktor\u00e1 je u\u017e vstavan\u00e1 v Pythone). Kr\u00e1tka uk\u00e1\u017eka ako funguje: >>> max ( [ 1 , 2 , 0 ] ) 2 >>> max ( 'dkrn' ) 'r' >>> max ( [] ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : max () arg is an empty sequence Tak\u017ee pozor na to, aby argumentom nebol pr\u00e1zdny zoznam, toto bude treba otestova\u0165 e\u0161te pred t\u00fdm, ako sa zavol\u00e1 funkcia max . \u010co ak by sme chceli aj my nie\u010do vr\u00e1ti\u0165 z na\u0161ej vlastnej funkcie, nielen vypisova\u0165? Sl\u00fa\u017ei na to slov\u00ed\u010dko return : def area ( a , b ): return a * b print ( area ( 2 , 3 ) ) print ( area ( 0 , 10 ) + area ( 10 , 0 ) ) print ( area ( 1 , area ( 2 , 3 ) ) ) # well, this is \"volume\" Prv\u00fd riadok (po defin\u00edcii funkcie area ) zavol\u00e1 area( 2, 3 ) . Do premennej a sa ulo\u017e\u00ed hodnota 2 , do b hodnota 3 . Potom sa vyhodnot\u00ed a * b na hodnotu 12 , ktor\u00e1 sa vr\u00e1ti spa\u0165 a vykon\u00e1 sa print( 12 ) . Podobne si vieme rozobra\u0165 aj posledn\u00fd riadok: print ( area ( 1 , area ( 2 , 3 ) ) ) print ( area ( 1 , 6 ) ) print ( 6 ) Na obrazovke uvid\u00edme text \"6\" \u00daloha Nap\u00ed\u0161te funkciu, ktor\u00e1 vr\u00e1ti po\u010det kladn\u00fdch \u010d\u00edsel v zozname. [] -> 0 [ 2, 3 ] -> 2 [ 0, 4, 9, -2, 10 ] -> 3 [ -2, 0, -5 ] -> 0","title":"Funkcie"},{"location":"03/#range","text":"Uk\u00e1\u017eeme si jednu nov\u00fa, u\u017eito\u010dn\u00fa funkciu, hlavne v spojen\u00ed s for ... in cyklom. Vol\u00e1 sa range a m\u00f4\u017ee bra\u0165 jeden, dva, alebo aj tri argumenty. Vr\u00e1ti \u0161peci\u00e1lnu hodnotu typu 'range', ktor\u00fa ale vieme konvertova\u0165 do zoznamu pomocou funkcie list : >>> list ( range ( 10 ) ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 0 ) ) [] >>> list ( range ( 1 ) ) [ 0 ] >>> list ( range ( 0 , 10 ) ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 0 , 0 ) ) [] >>> list ( range ( 3 , 5 ) ) [ 3 , 4 ] >>> list ( range ( - 3 , 3 ) ) [ - 3 , - 2 , - 1 , 0 , 1 , 2 ] >>> list ( range ( - 3 , 3 , 2 ) ) [ - 3 , - 1 , 1 ] >>> list ( range ( 0 , 10 , 1 ) ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> list ( range ( 0 , 10 , 3 ) ) [ 0 , 3 , 6 , 9 ] >>> list ( range ( 10 , 0 , - 3 ) ) [ 10 , 7 , 4 , 1 ] range(a, b, c) vygeneruje \u010d\u00edsla od a (vr\u00e1tane) do b (vyn\u00edmaj\u00fac) s rozdielmi c medzi ka\u017ed\u00fdmi dvomi \u010d\u00edslami. Ak pou\u017eijeme iba dva argumenty, c sa nastav\u00ed automaticky na jednotku. A ak iba jeden, a sa nastav\u00ed na nulu. Ak ale pou\u017eijeme t\u00fato funkciu s kon\u0161trukciou for ... in , m\u00f4\u017eme vynecha\u0165 konvertovanie cez list , lebo vie pracova\u0165 aj s \u0161peci\u00e1lnou hodnotou typu 'range', ak\u00fa vracia funkcia range . >>> type ( range ( 5 ) ) < class ' range '> >>> for i in range ( 5 ): ... print ( i ) ... 0 1 2 3 4 for spolu s range \u010dastokr\u00e1t dok\u00e1\u017ee nahradi\u0165 cyklus while a lep\u0161ie sa s n\u00edm pracuje. Ak si spomenieme napr. na n\u00e1\u0161 program kresliaci trojuholn\u00edky, teraz by sme samotn\u00e9 kreslenie (na\u010d\u00edtanie ve\u013ekosti na vstupe zost\u00e1va rovnako) vedeli nap\u00edsa\u0165 nasledovne: for row_size in range ( size , 0 , - 1 ): print ( row_size * '*' ) A nakresli\u0165 opa\u010dn\u00fd trojuholn\u00edk (so \u0161pi\u010dkou na vrchu) by bolo podobne jednoduch\u00e9: for row_size in range ( 1 , size + 1 ): print ( row_size * '*' ) \u00daloha Nap\u00ed\u0161te program, ktor\u00fd sa sp\u00fdta u\u017e\u00edvate\u013ea na dve \u010d\u00edsla. Tie bud\u00fa znamena\u0165 ve\u013ekos\u0165 str\u00e1n obd\u013a\u017enika. Potom pomocou for ... in range vykreslite tak\u00fdto obd\u013a\u017enik. Pre ve\u013ekosti 4 a 6 by mal vyzera\u0165 takto: ###### # # # # ######","title":"range"},{"location":"03/#labyrint","text":"Po\u010fme si spolu naprogramova\u0165 jednoduch\u00fa hru. U\u017e m\u00e1me nejak\u00e9 skusenosti s programovan\u00edm, tak\u017ee pok\u00fdm sa trochu obmedz\u00edme v na\u0161ich n\u00e1rokoch na kvalitu, zvl\u00e1dneme to \u013eavou zadnou. Cie\u013eom hry bude dosta\u0165 sa v labyrinte do cie\u013ea. Labyrint budeme kresli\u0165 podobne ako v poslednej \u00falohe, mrie\u017eky (#) bud\u00fa ozna\u010dova\u0165 steny, medzery ( ) vo\u013en\u00e9 pol\u00ed\u010dka. Cie\u013e ozna\u010d\u00edme ako p\u00edsmeno X a na\u0161u postavi\u010dku O. V ka\u017edom kole vyzveme pou\u017e\u00edvate\u013ea aby zadal jedno z p\u00edsmenok: w - krok hore a - krok v\u013eavo s - krok dole d - krok vpravo q - ukon\u010di\u0165 hru Na za\u010diatku si zadefinujeme v\u0161etky tieto kon\u0161tanty , teda premenn\u00e9, ktor\u00e9 sa nebud\u00fa meni\u0165. V Pythone je zvykom p\u00edsa\u0165 ich n\u00e1zvy ve\u013ek\u00fdmi p\u00edsmenami. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 FIELD = [ '#############' , '# # ### #X#' , '# # # #' , '# ## ## # # #' , '# # # #' , '##### # # #' , '# # #######' , '# # #' , '#############' ] HEIGHT = len ( FIELD ) WIDTH = len ( FIELD [ 0 ] ) END = 'X' PLAYER = 'O' WALL = '#' UP = 'w' LEFT = 'a' DOWN = 's' RIGHT = 'd' QUIT = 'q' Hracie pole si uklad\u00e1me ako zoznam textov\u00fdch re\u0165azcov - riadkov. V\u00fd\u0161ka po\u013ea je po\u010det riadkov, ktor\u00fd vieme zisti\u0165 funkciou len . Tie\u017e ju pou\u017eijeme na zistenie \u0161\u00edrky, t.j. po\u010det st\u013apcov, ktor\u00fd sa rovn\u00e1 d\u013a\u017eke ka\u017ed\u00e9ho (a teda napr. prv\u00e9ho) riadku. Na za\u010diatku hr\u00e1\u010da umiestnime do \u013eav\u00e9ho doln\u00e9ho rohu. Pam\u00e4tajme, \u017ee indexy za\u010d\u00ednaj\u00fa nulou. X-ov\u00e1 s\u00faradnica je horizont\u00e1lna (z\u013eava doprava), y-ov\u00e1 je vertik\u00e1lna (zhora dolu). 25 26 INITIAL_X = 1 INITIAL_Y = 7 Teraz si nap\u00ed\u0161eme funkciu, ktor\u00e1 vykresl\u00ed hracie pole aj s hr\u00e1\u010dom. Funkcia bude ma\u0165 dva parametre: aktu\u00e1lne s\u00faradnice hr\u00e1\u010da. Budeme prech\u00e1dza\u0165 pomocou vnoren\u00e9ho for cyklu cel\u00e9 hracie pole po riadkoch, ak na danom pol\u00ed\u010dku stoj\u00ed hr\u00e1\u010d, vykresl\u00edme jeho znak, inak vykresl\u00edme pol\u00ed\u010dko z hracieho pola. Doteraz sme print pou\u017e\u00edvali tak, \u017ee na konci v\u00fdstupu v\u017edy vlo\u017eil znak konca riadku (akoby stla\u010dil na konci riadku Enter ). To je jeho prednastaven\u00e9 spr\u00e1vanie. Teraz ale nechceme aby bolo ka\u017ed\u00e9 pol\u00ed\u010dko na svojom vlastnom riadku, chceme ich vykresli\u0165 hne\u010f ved\u013ea seba. Preto pou\u017eijeme \u0161peci\u00e1lny ( optional ) parameter end , kde mu nastav\u00edme znak, ktor\u00fd m\u00e1 vykresli\u0165 na konci v\u00fdstupu. Sk\u00faste si v shelli spusti\u0165 napr. print ( 'afad' , end = '###' ) . My naozaj nechceme vyp\u00edsa\u0165 medzi pol\u00ed\u010dkami ni\u010d, preto nastav\u00edme tento parameter na pr\u00e1zdny text. 28 29 30 31 32 33 34 35 def print_field ( player_x , player_y ): for y in range ( HEIGHT ): for x in range ( WIDTH ): if y == player_y and x == player_x : print ( PLAYER , end = '' ) else : print ( FIELD [ y ][ x ], end = '' ) print () Nap\u00ed\u0161eme si e\u0161te jednu d\u00f4le\u017eit\u00fa funkciu. Bude na\u010d\u00edtava\u0165 vstup od u\u017e\u00edvate\u013ea a pos\u00fava\u0165 hr\u00e1\u010da. Ako vstup zoberie tie\u017e s\u00faradnice hr\u00e1\u010da a vr\u00e1ti 3 hodnoty: nov\u00e9 s\u00faradnice po posune a logick\u00fa hodnotu, \u010di sa m\u00e1 hra ukon\u010di\u0165. Viac ako jednu hodnotu sme doteraz nevr\u00e1tili v \u017eiadnej funkcii, ale je to jednoduch\u00e9: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def is_valid_command ( command ): return command in 'wasdq' def is_empty ( x , y ): return not FIELD [ y ][ x ] == WALL def move ( player_x , player_y ): new_player_x = player_x new_player_y = player_y while True : command = input ( 'Move \"w\", \"a\", \"s\", \"d\" or end \"q\": ' ) if not is_valid_command ( command ): print ( 'Invalid command' ) else : if command == 'w' : new_player_y -= 1 elif command == 'a' : new_player_x -= 1 elif command == 's' : new_player_y += 1 elif command == 'd' : new_player_x += 1 else : # quit return player_x , player_y , True if is_empty ( new_player_x , new_player_y ): return new_player_x , new_player_y , False else : print ( 'You cannot move there' ) new_player_x = player_x new_player_y = player_y Teraz implementujeme hlavn\u00fa logiku. Na\u010d\u00edta\u0165 viacero hodn\u00f4t z funkcie je rovnako jednoduch\u00e9. 70 71 72 73 74 75 76 77 78 79 80 81 82 x = INITIAL_X y = INITIAL_Y end = False while not end : print_field ( x , y ) x , y , end = move ( x , y ) if not end and FIELD [ y ][ x ] == END : print ( 'Congratulation!' ) end = True print ( 'The game ends' ) Tak, a hra je hotov\u00e1 :) Nezabudnite, \u017ee pr\u00edkaz input v\u017edy \u010dak\u00e1 na stla\u010denie kl\u00e1vesy Enter , tak\u017ee sa hra ned\u00e1 ovl\u00e1da\u0165 plynule ako sme zvyknut\u00ed, len dr\u017ean\u00edm \"w\" \"a\" \"s\" \"d\". To by sme mohli e\u0161te vylep\u0161i\u0165, no najbli\u017e\u0161ie si u\u017e postav\u00edme svojho prv\u00e9ho robota a rozpohybujeme ho Pythonom! Z\u00e1rove\u0148 si postupne budeme ukazova\u0165 v\u0161eliak\u00e9 nov\u00e9 u\u017eito\u010dn\u00e9 pr\u00edkazy. \u00daloha Ak e\u0161te m\u00e1te chu\u0165 trochu popracova\u0165 na na\u0161ej hre, tu je nieko\u013eko n\u00e1vrhov: Vytvorte viacero r\u00f4znych blud\u00edsk, nechajte hr\u00e1\u010da, aby si z nich vybral. Pridajte po\u010d\u00edtadlo krokov. \u010c\u00edm viac krokov hr\u00e1\u010d sprav\u00ed pok\u00fdm sa dostane do cie\u013ea, t\u00fdm ni\u017e\u0161ie bude jeho sk\u00f3re, ktor\u00e9 na konci hra vyp\u00ed\u0161e. Do bludiska pridajte diamanty (napr. znak bodky \".\"), tie bude hr\u00e1\u010d zbiera\u0165, tak\u017ee po prejden\u00ed pol\u00ed\u010dka s diamantom, diamant na \u0148om u\u017e nesmie zosta\u0165! Pozbieran\u00e9 diamanty hr\u00e1\u010dovi zvy\u0161uj\u00fa sk\u00f3re. Do hry m\u00f4\u017eete prida\u0165 dvere \"D\" a k\u013e\u00fa\u010d \"K\". Ke\u010f hr\u00e1\u010d zoberie k\u013e\u00fa\u010d, dvere sa mu otvoria a bude m\u00f4c\u0165 prejs\u0165 do cie\u013ea.","title":"Labyrint"},{"location":"04/","text":"Prv\u00fd robot Dnes si postav\u00edme a naprogramujeme na\u0161eho prv\u00e9ho LEGO robota! Bude ma\u0165 dva motory aby sa vedel pohybova\u0165 a EV3-kocku ( EV3 brick ), ktor\u00e1 je tak\u00fdm mozgom cel\u00e9ho robota, bude riadi\u0165 motory, ktor\u00e9 pripoj\u00edme do nej k\u00e1blami. K\u00e1ble by sme mohli prirovna\u0165 k nervom a \u017eil\u00e1m v \u010dloveku. EV3-kocka je z\u00e1rove\u0148 aj srdcom -- v zadnej \u010dasti obsahuje bat\u00e9rie, bez ktor\u00fdch by mozog ani nohy (motory) nemohli fungova\u0165. N\u00e1vod ako robota postavi\u0165 n\u00e1jdete tu . Pr\u00edprava EV3-kocky Programy budeme st\u00e1le p\u00edsa\u0165 na po\u010d\u00edta\u010di a potom ich cez USB k\u00e1bel nahr\u00e1me do kocky. Aby EV3-kocka vedela spusti\u0165 Python, mus\u00edme jej trochu pom\u00f4c\u0165. Na micro SD kartu nahr\u00e1me \u0161peci\u00e1lny opera\u010dn\u00fd syst\u00e9m ev3dev . Ke\u010f bude SD karta v EV3-kocke a zapneme ju, spust\u00ed sa ev3dev . Ak sa chceme dosta\u0165 do p\u00f4vodn\u00e9ho re\u017eimu, jednoducho vypneme kocku, vytiahneme SD kartu a znovu spust\u00edme robota. Tip N\u00e1vod na pr\u00edpravu SD karty n\u00e1jdete na str\u00e1nkach ev3dev , kroky 1, 2 a 4. Pr\u00edprava po\u010d\u00edta\u010du Ke\u010f\u017ee EV3-kocka je omnoho jednoduch\u0161ie zariadenie ne\u017e be\u017en\u00fd po\u010d\u00edta\u010d, nebudeme na nej sp\u00fa\u0161\u0165a\u0165 skuto\u010dn\u00fd Python, ale jeho jednoduch\u0161iu verziu: MicroPython \u0161peci\u00e1lne upraven\u00fd pre LEGO, naz\u00fdva sa Pybricks . Tak budeme m\u00f4c\u0165 z Pythonu sp\u00fa\u0161\u0165a\u0165 LEGO motory, vykreslova\u0165 obr\u00e1zky na displeji, \u010di na\u010d\u00edtava\u0165 d\u00e1ta z r\u00f4znych senzorov. Aby sme tieto programy vedeli spusti\u0165 na EV3-kocke, potrebujeme vykona\u0165 e\u0161te nieko\u013eko vec\u00ed: Nain\u0161talova\u0165 si Visual Studio Code Spusti\u0165 ho Otvori\u0165 extension tab Vyh\u013eada\u0165 roz\u0161\u00edrenie EV3 MicroPython a nain\u0161talova\u0165 ho Tak a m\u00e1me v\u0161etko pripraven\u00e9 :) Vpred! Teraz si nap\u00ed\u0161eme prv\u00fd jednoduch\u00fd program, ktor\u00fd pohne robota o k\u00fasok vpred. Vo Visual Studio Code si vytvor\u00edme nov\u00fd projekt. Zad\u00e1me n\u00e1zov, napr. \"2motors\", a stla\u010d\u00edme Enter . Otvor\u00ed sa n\u00e1m prehliada\u010d s\u00faborov. Tu zvol\u00edme prie\u010dinok, kde chceme n\u00e1\u0161 projekt ma\u0165 ulo\u017een\u00fd. Dostaneme bezpe\u010dnostn\u00e9 upozornenie, \u010di ver\u00edme autorom s\u00faborov vo zvolenom prie\u010dinku. Za predpokladu, \u017ee v\u0161etky budeme p\u00edsa\u0165 my, potvrd\u00edme, \u017ee \u00e1no Vo zvolenom prie\u010dinku sa n\u00e1m vytvoril nov\u00fd projektov\u00fd prie\u010dinok s n\u00e1zvom ak\u00fd sme zvolili v kroku 2 (\"2motors\"). Ten obsahuje s\u00fabor main.py s k\u00f3dom, ktor\u00fd sa bude na robotovi sp\u00fa\u0161\u0165a\u0165. Vyma\u017eme po\u010diato\u010dn\u00fd vygenerovan\u00fd k\u00f3d v main.py a skop\u00edrujme do\u0148 tento: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait left_motor = Motor ( Port . B ) right_motor = Motor ( Port . C ) left_motor . run ( 360 ) right_motor . run ( 360 ) wait ( 2000 ) left_motor . stop () right_motor . stop () Vyzer\u00e1 trochu inak ako tie, \u010do sme p\u00edsali doteraz. Zatia\u013e sa t\u00fdm netr\u00e1pme, onedlho si v\u0161etko r\u00fdchlo vysvetl\u00edme. Teraz zapneme EV3-kocku (s SD kartou s nahrat\u00fdm ev3dev ), pr\u00edpoj\u00edme ju USB k\u00e1blom k po\u010d\u00edta\u010du a pripoj\u00edme sa ku nej z Visual Studio Code . Zvol\u00edme na\u0161u EV3-kocku. V\u013eavo dole by sme mali vidie\u0165 najprv \u017elt\u00fd kr\u00fa\u017eok (EV3-kocka sa prip\u00e1ja), potom zelen\u00fd, indikuj\u00faci \u00faspe\u0161n\u00e9 pripojenie. Ak je \u010derven\u00fd, spojenie zlyhalo. Klik prav\u00fdm -> \"Reconnect\" pre nov\u00fd pokus. Ak sa pripoji\u0165 nedar\u00ed a pou\u017e\u00edvate Ubuntu, m\u00f4\u017ee pom\u00f4c\u0165 nastavi\u0165 \"IPv4 Method\" na \"Shared to other computers\" vr\u00e1mci nastaven\u00ed siete \"USB Ethernet\". Teraz nahr\u00e1me program do EV3-kocky pomocou tla\u010didla vpravo od \"EV3DEV DEVICE BROWSER\" (v\u013eavo dole). Aby sme program spustili, mus\u00edme ho n\u00e1js\u0165 an EV3-kocke. Zvol\u00edme (stredn\u00fdm tla\u010didlom) File Browser -> 2motors -> main.py . Po spusten\u00ed sa motory na 2 sekundy rozbehn\u00fa a potom zastavia. To je v\u0161etko, \u010do n\u00e1\u0161 program teraz rob\u00ed. Cel\u00fd tento postup nahrania k\u00f3du do EV3-kocky a spustenie ho sa d\u00e1 spravi\u0165 naraz pomocou kl\u00e1vesu F5 , sk\u00faste si to. Vysvetlenie k\u00f3du Prejdime si teraz n\u00e1\u0161 program postupne, riadok po riadku: 1 #!/usr/bin/env pybricks-micropython Toto je \u0161peci\u00e1lny riadok, ktor\u00fd hovor\u00ed, ako (ak\u00fdm interpretrom ) spusti\u0165 nap\u00edsan\u00fd k\u00f3d. Nechceme ho spusti\u0165 ako klasick\u00fd Python, ktor\u00fd sme pou\u017e\u00edvali doteraz. Tento riadok tie\u017e budeme p\u00edsa\u0165 v ka\u017edom na\u0161om \u010fal\u0161om programe pre robota. V\u017edy mus\u00ed by\u0165 hne\u010f na za\u010diatku s\u00faboru. 3 4 5 from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait Zatia\u013e sme pou\u017e\u00edvali len be\u017en\u00e9 funkcie Pythonu, napr. sme ho pou\u017e\u00edvali ako jednoduch\u00fa kalkula\u010dku, pou\u017e\u00edvali sme print \u010di list . Ale existuje ve\u013emi ve\u013ea r\u00f4znych funkci\u00ed, ktor\u00e9 sa v Pythone daj\u00fa vyu\u017ei\u0165. Aby v nich bol aspo\u0148 trochu poriadok, delia sa na bal\u00ed\u010dky ( package ) a moduly ( module ). V\u00e4\u010d\u0161inu z nich je treba doin\u0161talova\u0165, my si vysta\u010d\u00edme s t\u00fdmi, ktor\u00e9 s\u00fa vstavan\u00e9 v Pybricks . Bal\u00ed\u010dek pybricks obsahuje v\u0161etko potrebn\u00e9 na riadenie EV3-kocky, motorov, komunik\u00e1ciu so senzormi. Tento bal\u00ed\u010dek obsahuje nieko\u013eko modulov. Napr. ev3devides , parameters , tools . No a tieto moduly zase obsahuj\u00fa funkcie a triedy (o triedach si povieme nie\u010do viac o chv\u00ed\u013eu) -- ak ich chceme v na\u0161om k\u00f3de vyu\u017ei\u0165, mus\u00edme si ich naimportova\u0165 : from package.module import function . A to presne sa deje na t\u00fdchto 4 riadkoch. Naimportujeme si triedy Motor , Port a funkciu wait , ktor\u00e9 budeme \u010falej pou\u017e\u00edva\u0165. Bez tohto import by sme dostali chybov\u00fa hl\u00e1\u0161ku ak by sme sa ich pok\u00fasili pou\u017ei\u0165. 8 9 left_motor = Motor ( Port . B ) right_motor = Motor ( Port . C ) Ty sme vyu\u017eili naimportovan\u00fa triedu ( class ) Motor . Trieda sl\u00fa\u017ei ako tov\u00e1re\u0148 na objekty ( object ). Tak\u00fdto objekt v po\u010d\u00edta\u010di \u010dasto reprezentuje nejak\u00fd objekt v re\u00e1lnom svete. Teraz je to jednoduch\u00e9. Motor vytvor\u00ed v pam\u00e4ti EV3 objekt, pomocou ktor\u00e9ho budeme ovl\u00e1da\u0165 skuto\u010dn\u00fd motor pripojen\u00fd k\u00e1blom na EV3-kocku. Aby sa n\u00e1m tento objekt v pam\u00e4ti nestratil, pomenujeme si ho. Ale n\u00e1\u0161 robot m\u00e1 dva motory, jeden pripojen\u00fd k portu B , druh\u00fd k portu C . Mus\u00edme tov\u00e1rni poveda\u0165: \"Teraz mi vyrob motor (objekt triedy Motor), ktor\u00fd je pripojen\u00fd na porte B. Teraz zase chcem motor pripojen\u00fd na C-\u010dko.\" Podobne ako sme d\u00e1vali argumenty do funkci\u00ed (napr. \"ahoj\" je argumentom v print ( \"ahoj\" ) ), argumenty d\u00e1vame aj ke\u010f vytv\u00e1rame objekty pomocou tried. Port.B je sp\u00f4sob ako poveda\u0165, \u017ee motor je pripojen\u00fd k portu B . Tak\u017ee po vykonan\u00ed t\u00fdchto dvoch riadkov, v pam\u00e4ti EV3 s\u00fa dva motory, jeden pomenovan\u00fd left_motor , pripojen\u00fd na port B , a druh\u00fd, right_motor , pripojen\u00fd na port C . Pozn\u00e1mka k triedam Ak si pam\u00e4t\u00e1te, slov\u00ed\u010dko \"class\" sme u\u017e niekde videli. >>> type ( \"hello\" ) < class ' str '> >>> type ( 1 ) < class ' int '> >>> type ( [ 1 , 2 , 3 ] ) < class ' list '> Vlastne v\u0161etko je v Pythone objekt. \"hello\" povie tov\u00e1rni triedy str aby vytvorila objekt -- text \"hello\". 1 vytvor\u00ed tie\u017e objekt -- \u010d\u00edslo 1. A rovnako pre list aj, v podstate, v\u0161etko ostatn\u00e9 :) 11 12 left_motor . run ( 360 ) right_motor . run ( 360 ) Ke\u010f chceme k vytvoren\u00fdm objektom pristupova\u0165, pou\u017eijeme bodku . . Ako sme zvykli zavola\u0165 funkciu ( print ( \"hello\" ) ), tak zavol\u00e1me aj funkciu priraden\u00fa k objektu, tzv. met\u00f3du ( method ): objekt.met\u00f3da(argumenty) . Funkcia print jednoducho vyp\u00ed\u0161e dan\u00fd text na obrazovku. Ale run potrebuje vedie\u0165, ak\u00fd motor m\u00e1 spusti\u0165, preto je priraden\u00e1 k objektu, a teda nie je len funkciou , ale met\u00f3dou . Parameter met\u00f3dy run je r\u00fdchlos\u0165, akou motor bude spusten\u00fd, v stup\u0148och za sekundu. Ke\u010f\u017ee kruh m\u00e1 360 stup\u0148ov, je to r\u00fdchlos\u0165 1 RPM ( rotates per minute ), 1 oto\u010denie kolesa za sekundu. Ak by sme pou\u017eili z\u00e1porn\u00fa hodnotu, motor by sa ot\u00e1\u010dal do druhej strany. Tieto dva pr\u00edkazy teda spustia oba motory rovnakou r\u00fdchlos\u0165ou. A bud\u00fa be\u017ea\u0165 a\u017e pok\u00fdm ich znovu nevypneme. 14 wait ( 2000 ) Funkcia wait jednoducho zastav\u00ed vykon\u00e1vanie programu na dan\u00fd po\u010det milisek\u00fand. Tak\u017ee vykon\u00e1vanie po\u010dk\u00e1 na tomto riadku 2 sekundy (1 sekunda m\u00e1 1000 milisek\u00fand). Po\u010das tejto doby sa ni\u010d nov\u00e9 nedeje, motory s\u00fa st\u00e1le zapnut\u00e9. 16 17 left_motor . stop () right_motor . stop () Po ubehnut\u00ed 2 sek\u00fand oba motory vypneme met\u00f3dou stop , ktor\u00e1 neberie \u017eiadne argumenty. Tak\u017ee koles\u00e1 by sa mali oto\u010di\u0165 (pribli\u017ene) o dve cel\u00e9 ot\u00e1\u010dky -- skontrolujte to :) \u00daloha Vysk\u00fa\u0161ajte si program r\u00f4zne upravova\u0165. Vysk\u00fa\u0161ajte ako r\u00fdchlo dok\u00e1\u017ee robot \u00eds\u0165. Naprogramujte ho tak, aby \u0161iel dozadu, nie dopredu. \u010co sa stane, ak spust\u00edte len jeden motor, zatia\u013e \u010do druh\u00fd bude st\u00e1\u0165? Ako oto\u010di\u0165 robota na mieste? Zamyslite sa, ak\u00fa r\u00fdchlos\u0165 treba nastavi\u0165 motorom, aby sa robot pohyboval do kruhu. Pr\u00edklad Teraz si uk\u00e1\u017eeme zauj\u00edmavej\u0161\u00ed pohyb -- do \u0161pir\u00e1ly. Za\u010dneme v strede a postupne budeme robi\u0165 akoby v\u00e4\u010d\u0161\u00ed a v\u00e4\u010d\u0161\u00ed kruh. U\u017e vieme, \u017ee na pohyb do kruhu je potrebn\u00e9 jedn\u00e9mu motoru udeli\u0165 v\u00e4\u010d\u0161iu r\u00fdchlos\u0165 ne\u017e druh\u00e9mu. A \u010d\u00edm je tento rozdiel r\u00fdchlost\u00ed men\u0161\u00ed, t\u00fdm je kruh v\u00e4\u010d\u0161\u00ed. A\u017e pok\u00fdm nebude rozdiel nulov\u00fd, vtedy p\u00f4jde robot rovno. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait left_motor = Motor ( Port . B ) right_motor = Motor ( Port . C ) left_motor . run ( 360 ) for right_speed in range ( 1000 , 359 , - 1 ): right_motor . run ( right_speed ) wait ( 20 ) wait ( 1000 ) left_motor . stop () right_motor . stop () Na postupn\u00e9 zni\u017eovanie r\u00fdchlosti motoru C sme pou\u017eili n\u00e1m u\u017e zn\u00e1mu kon\u0161trukciu for ... in range ( ... ) . range generuje \u010d\u00edsla od prv\u00e9ho vr\u00e1tane, po posledn\u00e9, ale zastav\u00ed sa jeden krok pred n\u00edm, preto sme pou\u017eili 359 , aby na konci bola r\u00fdchlos\u0165 o jedna v\u00e4\u010d\u0161ia, teda 360 , a robot \u0161iel rovno. Na dnes toho bolo u\u017e dos\u0165, nabud\u00face si uk\u00e1\u017eeme jeden sp\u00f4sob ako p\u00fa\u0161\u0165a\u0165 motory o nie\u010do presnej\u0161ie, a tie\u017e pou\u017eijeme prv\u00fd kr\u00e1t senzor! Bude to tla\u010didlov\u00fd senzor, ktor\u00fdm m\u00f4\u017eeme napr. od\u0161tartova\u0165 r\u00f4zne akcie robota alebo detekova\u0165 zr\u00e1\u017eku s in\u00fdm predmetom.","title":"Prv\u00fd robot"},{"location":"04/#prvy-robot","text":"Dnes si postav\u00edme a naprogramujeme na\u0161eho prv\u00e9ho LEGO robota! Bude ma\u0165 dva motory aby sa vedel pohybova\u0165 a EV3-kocku ( EV3 brick ), ktor\u00e1 je tak\u00fdm mozgom cel\u00e9ho robota, bude riadi\u0165 motory, ktor\u00e9 pripoj\u00edme do nej k\u00e1blami. K\u00e1ble by sme mohli prirovna\u0165 k nervom a \u017eil\u00e1m v \u010dloveku. EV3-kocka je z\u00e1rove\u0148 aj srdcom -- v zadnej \u010dasti obsahuje bat\u00e9rie, bez ktor\u00fdch by mozog ani nohy (motory) nemohli fungova\u0165. N\u00e1vod ako robota postavi\u0165 n\u00e1jdete tu .","title":"Prv\u00fd robot"},{"location":"04/#priprava-ev3-kocky","text":"Programy budeme st\u00e1le p\u00edsa\u0165 na po\u010d\u00edta\u010di a potom ich cez USB k\u00e1bel nahr\u00e1me do kocky. Aby EV3-kocka vedela spusti\u0165 Python, mus\u00edme jej trochu pom\u00f4c\u0165. Na micro SD kartu nahr\u00e1me \u0161peci\u00e1lny opera\u010dn\u00fd syst\u00e9m ev3dev . Ke\u010f bude SD karta v EV3-kocke a zapneme ju, spust\u00ed sa ev3dev . Ak sa chceme dosta\u0165 do p\u00f4vodn\u00e9ho re\u017eimu, jednoducho vypneme kocku, vytiahneme SD kartu a znovu spust\u00edme robota. Tip N\u00e1vod na pr\u00edpravu SD karty n\u00e1jdete na str\u00e1nkach ev3dev , kroky 1, 2 a 4.","title":"Pr\u00edprava EV3-kocky"},{"location":"04/#priprava-pocitacu","text":"Ke\u010f\u017ee EV3-kocka je omnoho jednoduch\u0161ie zariadenie ne\u017e be\u017en\u00fd po\u010d\u00edta\u010d, nebudeme na nej sp\u00fa\u0161\u0165a\u0165 skuto\u010dn\u00fd Python, ale jeho jednoduch\u0161iu verziu: MicroPython \u0161peci\u00e1lne upraven\u00fd pre LEGO, naz\u00fdva sa Pybricks . Tak budeme m\u00f4c\u0165 z Pythonu sp\u00fa\u0161\u0165a\u0165 LEGO motory, vykreslova\u0165 obr\u00e1zky na displeji, \u010di na\u010d\u00edtava\u0165 d\u00e1ta z r\u00f4znych senzorov. Aby sme tieto programy vedeli spusti\u0165 na EV3-kocke, potrebujeme vykona\u0165 e\u0161te nieko\u013eko vec\u00ed: Nain\u0161talova\u0165 si Visual Studio Code Spusti\u0165 ho Otvori\u0165 extension tab Vyh\u013eada\u0165 roz\u0161\u00edrenie EV3 MicroPython a nain\u0161talova\u0165 ho Tak a m\u00e1me v\u0161etko pripraven\u00e9 :)","title":"Pr\u00edprava po\u010d\u00edta\u010du"},{"location":"04/#vpred","text":"Teraz si nap\u00ed\u0161eme prv\u00fd jednoduch\u00fd program, ktor\u00fd pohne robota o k\u00fasok vpred. Vo Visual Studio Code si vytvor\u00edme nov\u00fd projekt. Zad\u00e1me n\u00e1zov, napr. \"2motors\", a stla\u010d\u00edme Enter . Otvor\u00ed sa n\u00e1m prehliada\u010d s\u00faborov. Tu zvol\u00edme prie\u010dinok, kde chceme n\u00e1\u0161 projekt ma\u0165 ulo\u017een\u00fd. Dostaneme bezpe\u010dnostn\u00e9 upozornenie, \u010di ver\u00edme autorom s\u00faborov vo zvolenom prie\u010dinku. Za predpokladu, \u017ee v\u0161etky budeme p\u00edsa\u0165 my, potvrd\u00edme, \u017ee \u00e1no Vo zvolenom prie\u010dinku sa n\u00e1m vytvoril nov\u00fd projektov\u00fd prie\u010dinok s n\u00e1zvom ak\u00fd sme zvolili v kroku 2 (\"2motors\"). Ten obsahuje s\u00fabor main.py s k\u00f3dom, ktor\u00fd sa bude na robotovi sp\u00fa\u0161\u0165a\u0165. Vyma\u017eme po\u010diato\u010dn\u00fd vygenerovan\u00fd k\u00f3d v main.py a skop\u00edrujme do\u0148 tento: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait left_motor = Motor ( Port . B ) right_motor = Motor ( Port . C ) left_motor . run ( 360 ) right_motor . run ( 360 ) wait ( 2000 ) left_motor . stop () right_motor . stop () Vyzer\u00e1 trochu inak ako tie, \u010do sme p\u00edsali doteraz. Zatia\u013e sa t\u00fdm netr\u00e1pme, onedlho si v\u0161etko r\u00fdchlo vysvetl\u00edme. Teraz zapneme EV3-kocku (s SD kartou s nahrat\u00fdm ev3dev ), pr\u00edpoj\u00edme ju USB k\u00e1blom k po\u010d\u00edta\u010du a pripoj\u00edme sa ku nej z Visual Studio Code . Zvol\u00edme na\u0161u EV3-kocku. V\u013eavo dole by sme mali vidie\u0165 najprv \u017elt\u00fd kr\u00fa\u017eok (EV3-kocka sa prip\u00e1ja), potom zelen\u00fd, indikuj\u00faci \u00faspe\u0161n\u00e9 pripojenie. Ak je \u010derven\u00fd, spojenie zlyhalo. Klik prav\u00fdm -> \"Reconnect\" pre nov\u00fd pokus. Ak sa pripoji\u0165 nedar\u00ed a pou\u017e\u00edvate Ubuntu, m\u00f4\u017ee pom\u00f4c\u0165 nastavi\u0165 \"IPv4 Method\" na \"Shared to other computers\" vr\u00e1mci nastaven\u00ed siete \"USB Ethernet\". Teraz nahr\u00e1me program do EV3-kocky pomocou tla\u010didla vpravo od \"EV3DEV DEVICE BROWSER\" (v\u013eavo dole). Aby sme program spustili, mus\u00edme ho n\u00e1js\u0165 an EV3-kocke. Zvol\u00edme (stredn\u00fdm tla\u010didlom) File Browser -> 2motors -> main.py . Po spusten\u00ed sa motory na 2 sekundy rozbehn\u00fa a potom zastavia. To je v\u0161etko, \u010do n\u00e1\u0161 program teraz rob\u00ed. Cel\u00fd tento postup nahrania k\u00f3du do EV3-kocky a spustenie ho sa d\u00e1 spravi\u0165 naraz pomocou kl\u00e1vesu F5 , sk\u00faste si to.","title":"Vpred!"},{"location":"04/#vysvetlenie-kodu","text":"Prejdime si teraz n\u00e1\u0161 program postupne, riadok po riadku: 1 #!/usr/bin/env pybricks-micropython Toto je \u0161peci\u00e1lny riadok, ktor\u00fd hovor\u00ed, ako (ak\u00fdm interpretrom ) spusti\u0165 nap\u00edsan\u00fd k\u00f3d. Nechceme ho spusti\u0165 ako klasick\u00fd Python, ktor\u00fd sme pou\u017e\u00edvali doteraz. Tento riadok tie\u017e budeme p\u00edsa\u0165 v ka\u017edom na\u0161om \u010fal\u0161om programe pre robota. V\u017edy mus\u00ed by\u0165 hne\u010f na za\u010diatku s\u00faboru. 3 4 5 from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait Zatia\u013e sme pou\u017e\u00edvali len be\u017en\u00e9 funkcie Pythonu, napr. sme ho pou\u017e\u00edvali ako jednoduch\u00fa kalkula\u010dku, pou\u017e\u00edvali sme print \u010di list . Ale existuje ve\u013emi ve\u013ea r\u00f4znych funkci\u00ed, ktor\u00e9 sa v Pythone daj\u00fa vyu\u017ei\u0165. Aby v nich bol aspo\u0148 trochu poriadok, delia sa na bal\u00ed\u010dky ( package ) a moduly ( module ). V\u00e4\u010d\u0161inu z nich je treba doin\u0161talova\u0165, my si vysta\u010d\u00edme s t\u00fdmi, ktor\u00e9 s\u00fa vstavan\u00e9 v Pybricks . Bal\u00ed\u010dek pybricks obsahuje v\u0161etko potrebn\u00e9 na riadenie EV3-kocky, motorov, komunik\u00e1ciu so senzormi. Tento bal\u00ed\u010dek obsahuje nieko\u013eko modulov. Napr. ev3devides , parameters , tools . No a tieto moduly zase obsahuj\u00fa funkcie a triedy (o triedach si povieme nie\u010do viac o chv\u00ed\u013eu) -- ak ich chceme v na\u0161om k\u00f3de vyu\u017ei\u0165, mus\u00edme si ich naimportova\u0165 : from package.module import function . A to presne sa deje na t\u00fdchto 4 riadkoch. Naimportujeme si triedy Motor , Port a funkciu wait , ktor\u00e9 budeme \u010falej pou\u017e\u00edva\u0165. Bez tohto import by sme dostali chybov\u00fa hl\u00e1\u0161ku ak by sme sa ich pok\u00fasili pou\u017ei\u0165. 8 9 left_motor = Motor ( Port . B ) right_motor = Motor ( Port . C ) Ty sme vyu\u017eili naimportovan\u00fa triedu ( class ) Motor . Trieda sl\u00fa\u017ei ako tov\u00e1re\u0148 na objekty ( object ). Tak\u00fdto objekt v po\u010d\u00edta\u010di \u010dasto reprezentuje nejak\u00fd objekt v re\u00e1lnom svete. Teraz je to jednoduch\u00e9. Motor vytvor\u00ed v pam\u00e4ti EV3 objekt, pomocou ktor\u00e9ho budeme ovl\u00e1da\u0165 skuto\u010dn\u00fd motor pripojen\u00fd k\u00e1blom na EV3-kocku. Aby sa n\u00e1m tento objekt v pam\u00e4ti nestratil, pomenujeme si ho. Ale n\u00e1\u0161 robot m\u00e1 dva motory, jeden pripojen\u00fd k portu B , druh\u00fd k portu C . Mus\u00edme tov\u00e1rni poveda\u0165: \"Teraz mi vyrob motor (objekt triedy Motor), ktor\u00fd je pripojen\u00fd na porte B. Teraz zase chcem motor pripojen\u00fd na C-\u010dko.\" Podobne ako sme d\u00e1vali argumenty do funkci\u00ed (napr. \"ahoj\" je argumentom v print ( \"ahoj\" ) ), argumenty d\u00e1vame aj ke\u010f vytv\u00e1rame objekty pomocou tried. Port.B je sp\u00f4sob ako poveda\u0165, \u017ee motor je pripojen\u00fd k portu B . Tak\u017ee po vykonan\u00ed t\u00fdchto dvoch riadkov, v pam\u00e4ti EV3 s\u00fa dva motory, jeden pomenovan\u00fd left_motor , pripojen\u00fd na port B , a druh\u00fd, right_motor , pripojen\u00fd na port C . Pozn\u00e1mka k triedam Ak si pam\u00e4t\u00e1te, slov\u00ed\u010dko \"class\" sme u\u017e niekde videli. >>> type ( \"hello\" ) < class ' str '> >>> type ( 1 ) < class ' int '> >>> type ( [ 1 , 2 , 3 ] ) < class ' list '> Vlastne v\u0161etko je v Pythone objekt. \"hello\" povie tov\u00e1rni triedy str aby vytvorila objekt -- text \"hello\". 1 vytvor\u00ed tie\u017e objekt -- \u010d\u00edslo 1. A rovnako pre list aj, v podstate, v\u0161etko ostatn\u00e9 :) 11 12 left_motor . run ( 360 ) right_motor . run ( 360 ) Ke\u010f chceme k vytvoren\u00fdm objektom pristupova\u0165, pou\u017eijeme bodku . . Ako sme zvykli zavola\u0165 funkciu ( print ( \"hello\" ) ), tak zavol\u00e1me aj funkciu priraden\u00fa k objektu, tzv. met\u00f3du ( method ): objekt.met\u00f3da(argumenty) . Funkcia print jednoducho vyp\u00ed\u0161e dan\u00fd text na obrazovku. Ale run potrebuje vedie\u0165, ak\u00fd motor m\u00e1 spusti\u0165, preto je priraden\u00e1 k objektu, a teda nie je len funkciou , ale met\u00f3dou . Parameter met\u00f3dy run je r\u00fdchlos\u0165, akou motor bude spusten\u00fd, v stup\u0148och za sekundu. Ke\u010f\u017ee kruh m\u00e1 360 stup\u0148ov, je to r\u00fdchlos\u0165 1 RPM ( rotates per minute ), 1 oto\u010denie kolesa za sekundu. Ak by sme pou\u017eili z\u00e1porn\u00fa hodnotu, motor by sa ot\u00e1\u010dal do druhej strany. Tieto dva pr\u00edkazy teda spustia oba motory rovnakou r\u00fdchlos\u0165ou. A bud\u00fa be\u017ea\u0165 a\u017e pok\u00fdm ich znovu nevypneme. 14 wait ( 2000 ) Funkcia wait jednoducho zastav\u00ed vykon\u00e1vanie programu na dan\u00fd po\u010det milisek\u00fand. Tak\u017ee vykon\u00e1vanie po\u010dk\u00e1 na tomto riadku 2 sekundy (1 sekunda m\u00e1 1000 milisek\u00fand). Po\u010das tejto doby sa ni\u010d nov\u00e9 nedeje, motory s\u00fa st\u00e1le zapnut\u00e9. 16 17 left_motor . stop () right_motor . stop () Po ubehnut\u00ed 2 sek\u00fand oba motory vypneme met\u00f3dou stop , ktor\u00e1 neberie \u017eiadne argumenty. Tak\u017ee koles\u00e1 by sa mali oto\u010di\u0165 (pribli\u017ene) o dve cel\u00e9 ot\u00e1\u010dky -- skontrolujte to :) \u00daloha Vysk\u00fa\u0161ajte si program r\u00f4zne upravova\u0165. Vysk\u00fa\u0161ajte ako r\u00fdchlo dok\u00e1\u017ee robot \u00eds\u0165. Naprogramujte ho tak, aby \u0161iel dozadu, nie dopredu. \u010co sa stane, ak spust\u00edte len jeden motor, zatia\u013e \u010do druh\u00fd bude st\u00e1\u0165? Ako oto\u010di\u0165 robota na mieste? Zamyslite sa, ak\u00fa r\u00fdchlos\u0165 treba nastavi\u0165 motorom, aby sa robot pohyboval do kruhu. Pr\u00edklad Teraz si uk\u00e1\u017eeme zauj\u00edmavej\u0161\u00ed pohyb -- do \u0161pir\u00e1ly. Za\u010dneme v strede a postupne budeme robi\u0165 akoby v\u00e4\u010d\u0161\u00ed a v\u00e4\u010d\u0161\u00ed kruh. U\u017e vieme, \u017ee na pohyb do kruhu je potrebn\u00e9 jedn\u00e9mu motoru udeli\u0165 v\u00e4\u010d\u0161iu r\u00fdchlos\u0165 ne\u017e druh\u00e9mu. A \u010d\u00edm je tento rozdiel r\u00fdchlost\u00ed men\u0161\u00ed, t\u00fdm je kruh v\u00e4\u010d\u0161\u00ed. A\u017e pok\u00fdm nebude rozdiel nulov\u00fd, vtedy p\u00f4jde robot rovno. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait left_motor = Motor ( Port . B ) right_motor = Motor ( Port . C ) left_motor . run ( 360 ) for right_speed in range ( 1000 , 359 , - 1 ): right_motor . run ( right_speed ) wait ( 20 ) wait ( 1000 ) left_motor . stop () right_motor . stop () Na postupn\u00e9 zni\u017eovanie r\u00fdchlosti motoru C sme pou\u017eili n\u00e1m u\u017e zn\u00e1mu kon\u0161trukciu for ... in range ( ... ) . range generuje \u010d\u00edsla od prv\u00e9ho vr\u00e1tane, po posledn\u00e9, ale zastav\u00ed sa jeden krok pred n\u00edm, preto sme pou\u017eili 359 , aby na konci bola r\u00fdchlos\u0165 o jedna v\u00e4\u010d\u0161ia, teda 360 , a robot \u0161iel rovno. Na dnes toho bolo u\u017e dos\u0165, nabud\u00face si uk\u00e1\u017eeme jeden sp\u00f4sob ako p\u00fa\u0161\u0165a\u0165 motory o nie\u010do presnej\u0161ie, a tie\u017e pou\u017eijeme prv\u00fd kr\u00e1t senzor! Bude to tla\u010didlov\u00fd senzor, ktor\u00fdm m\u00f4\u017eeme napr. od\u0161tartova\u0165 r\u00f4zne akcie robota alebo detekova\u0165 zr\u00e1\u017eku s in\u00fdm predmetom.","title":"Vysvetlenie k\u00f3du"}]}